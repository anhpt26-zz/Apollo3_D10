###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.6.265/W32 for ARM         08/Jul/2021  07:47:45
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        \\Mac\Home\Documents\Apollo3\A3_SDK\utils\am_util_stdio.c
#    Command line      =
#        -f C:\Users\ADMINI~1\AppData\Local\Temp\EWF4AB.tmp
#        (\\Mac\Home\Documents\Apollo3\A3_SDK\utils\am_util_stdio.c -D iar -D
#        AM_UTIL_FAULTISR_PRINT -D AM_FREERTOS -D APS6404L -D AM_DEBUG_PRINTF
#        -D AM_PART_APOLLO3P -D AM_PACKAGE_BGA -lcN
#        \\Mac\Home\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_mspi_mspi_display\iar\bin
#        --diag_suppress Pa050 -o
#        \\Mac\Home\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_mspi_mspi_display\iar\bin
#        --debug --endian=little --cpu=Cortex-M4 --no_path_in_file_macros -e
#        --fpu=VFPv4_sp --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        \\Mac\Home\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_mspi_mspi_display\iar\..\..\..\..\..\mcu\apollo3p\\
#        -I
#        \\Mac\Home\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_mspi_mspi_display\iar\..\src\\
#        -I
#        \\Mac\Home\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_mspi_mspi_display\iar\..\..\..\..\..\third_party\FreeRTOSv10.1.1\Source\portable\IAR\AMapollo2\\
#        -I
#        \\Mac\Home\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_mspi_mspi_display\iar\..\..\..\..\..\CMSIS\AmbiqMicro\Include\\
#        -I
#        \\Mac\Home\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_mspi_mspi_display\iar\..\..\..\..\..\devices\\
#        -I
#        \\Mac\Home\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_mspi_mspi_display\iar\..\..\..\bsp\\
#        -I
#        \\Mac\Home\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_mspi_mspi_display\iar\..\..\..\..\..\third_party\FreeRTOSv10.1.1\Source\include\\
#        -I
#        \\Mac\Home\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_mspi_mspi_display\iar\..\..\..\..\..\\
#        -I
#        \\Mac\Home\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_mspi_mspi_display\iar\..\..\..\..\..\CMSIS\ARM\Include\\
#        -I
#        \\Mac\Home\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_mspi_mspi_display\iar\..\..\..\..\..\utils\\
#        -Ohs --no_size_constraints)
#    Locale            =  C
#    List file         =
#        \\Mac\Home\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_mspi_mspi_display\iar\bin\am_util_stdio.lst
#    Object file       =
#        \\Mac\Home\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_mspi_mspi_display\iar\bin\am_util_stdio.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

\\Mac\Home\Documents\Apollo3\A3_SDK\utils\am_util_stdio.c
      1          //*****************************************************************************
      2          //
      3          //! @file am_util_stdio.c
      4          //!
      5          //! @brief A few printf-style functions for use with Ambiq products
      6          //!
      7          //! Functions for performing printf-style operations without dynamic memory
      8          //! allocation.
      9          //!
     10          //! For further information about this module concerning its history, uses,
     11          //! and limitations, please see the Ambiq Micro KB article "Q&A: What does
     12          //! the AmbiqSuite SDK am_util_stdio_printf() function do?" at:
     13          //!
     14          //! https://support.ambiqmicro.com/hc/en-us/articles/360040441631
     15          //!
     16          //
     17          //*****************************************************************************
     18          
     19          //*****************************************************************************
     20          //
     21          // Copyright (c) 2020, Ambiq Micro, Inc.
     22          // All rights reserved.
     23          //
     24          // Redistribution and use in source and binary forms, with or without
     25          // modification, are permitted provided that the following conditions are met:
     26          //
     27          // 1. Redistributions of source code must retain the above copyright notice,
     28          // this list of conditions and the following disclaimer.
     29          //
     30          // 2. Redistributions in binary form must reproduce the above copyright
     31          // notice, this list of conditions and the following disclaimer in the
     32          // documentation and/or other materials provided with the distribution.
     33          //
     34          // 3. Neither the name of the copyright holder nor the names of its
     35          // contributors may be used to endorse or promote products derived from this
     36          // software without specific prior written permission.
     37          //
     38          // Third party software included in this distribution is subject to the
     39          // additional license terms as defined in the /docs/licenses directory.
     40          //
     41          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     42          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     43          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     44          // ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     45          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     46          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     47          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     48          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     49          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     50          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     51          // POSSIBILITY OF SUCH DAMAGE.
     52          //
     53          // This is part of revision 2.5.1 of the AmbiqSuite Development Package.
     54          //
     55          //*****************************************************************************
     56          
     57          #include <stdint.h>
     58          #include <stdbool.h>
     59          #include <stdarg.h>
     60          #include "am_util_stdio.h"
     61          
     62          //*****************************************************************************
     63          //
     64          // Global Variables
     65          //
     66          //*****************************************************************************
     67          
     68          // function pointer for printf
     69          am_util_stdio_print_char_t g_pfnCharPrint;
     70          
     71          // buffer for printf
     72          static char g_prfbuf[AM_PRINTF_BUFSIZE];
     73          
     74          // Flag to do conversion of '\n' to '\n\r' in sprintf()
     75          static bool g_bTxtXlate = false;
     76          
     77          //*****************************************************************************
     78          //
     79          //! @brief Sets the interface for printf calls.
     80          //!
     81          //! @param pfnCharPrint - Function pointer to be used to print to interface
     82          //!
     83          //! This function initializes the global print function which is used for
     84          //! printf. This allows users to define their own printf interface and pass it
     85          //! in as a am_util_stdio_print_char_t type.
     86          //!
     87          //! @return None.
     88          //
     89          //*****************************************************************************
     90          void
     91          am_util_stdio_printf_init(am_util_stdio_print_char_t pfnCharPrint)
     92          {
     93              g_pfnCharPrint = pfnCharPrint;
     94          }
     95          
     96          //*****************************************************************************
     97          //
     98          //! @brief Converts strings to 32-bit unsigned integers.
     99          //!
    100          //! @param *str - Pointer to the string to convert
    101          //! @param **endptr - strtoul will set this to the char after the converted num
    102          //! @param base - Base of the number as written in the input string.
    103          //!
    104          //! This function was implemented in a way similar to the strtoul function
    105          //! found in the C standard library. It will attempt to extract a numerical
    106          //! value from the input string, and return it to the caller. Invalid input
    107          //! strings will return a value of zero.
    108          //!
    109          //! @return uint32_t representing the numerical value from the string.
    110          //
    111          //*****************************************************************************
    112          uint32_t
    113          am_util_stdio_strtoul(const char *str, char **endptr, int base)
    114          {
    115              char *pos;
    116              uint32_t ui32BaseVal;
    117              uint32_t ui32RetVal;
    118          
    119              //
    120              // Prepare a pointer to start advancing through the string.
    121              //
    122              pos = (char *)str;
    123          
    124              //
    125              // Determine what base we are using. Default to '16', but change to other
    126              // values as specified by the user. If the user didn't specify anything,
    127              // try to guess the base value from looking at the first few characters of
    128              // the input
    129              //
    130              ui32BaseVal = 16;
    131          
    132              //
    133              // Switch to octal for a leading zero
    134              //
    135              if (*pos == '0')
    136              {
    137                  ui32BaseVal = 8;
    138                  pos++;
    139          
    140                  //
    141                  // Switch back to hex for a leading '0x'
    142                  //
    143                  if (*pos == 'x')
    144                  {
    145                      ui32BaseVal = 16;
    146                      pos++;
    147                  }
    148              }
    149          
    150              //
    151              // No matter what, if the user specified a base value, use that as the real
    152              // base value.
    153              //
    154              if (base)
    155              {
    156                  ui32BaseVal = base;
    157              }
    158          
    159              //
    160              // Start accumulating the converted integer value
    161              //
    162              ui32RetVal = 0;
    163          
    164              //
    165              // Loop through the digits, one character at a time. End the loop if the
    166              // number is out of range
    167              //
    168              while ((*pos >= 'a' && *pos <= 'f' && ui32BaseVal == 16) ||
    169                     (*pos >= 'A' && *pos <= 'F' && ui32BaseVal == 16) ||
    170                     (*pos >= '0' && *pos <= '9'))
    171              {
    172                  //
    173                  // Make sure to stop if we hit a NULL byte.
    174                  //
    175                  if (*pos == 0)
    176                  {
    177                      break;
    178                  }
    179          
    180                  //
    181                  // Multiply by the base value to move up one 'digit'
    182                  //
    183                  ui32RetVal *= ui32BaseVal;
    184          
    185                  //
    186                  // Add the value of the next character.
    187                  //
    188                  if (*pos >= '0' && *pos <= '9')
    189                  {
    190                      ui32RetVal += *pos - '0';
    191                  }
    192                  else if (*pos >= 'A' && *pos <= 'F')
    193                  {
    194                      ui32RetVal += (*pos - 'A') + 10;
    195                  }
    196                  else
    197                  {
    198                      ui32RetVal += (*pos - 'a') + 10;
    199                  }
    200          
    201                  //
    202                  // Grab the next character.
    203                  //
    204                  pos++;
    205              }
    206          
    207              //
    208              // If we get here, hopefully it means that we have parsed a number
    209              // correctly. The 'pos' pointer should already be pointing at the character
    210              // right after the last valid number, so set the enptr appropriately, and
    211              // return the calculated numerical value of the string.
    212              //
    213              if (endptr)
    214              {
    215                  *endptr = pos;
    216              }
    217          
    218              return ui32RetVal;
    219          }
    220          
    221          //*****************************************************************************
    222          //
    223          //  Divide an unsigned 32-bit value by 10.
    224          //
    225          //  Note: Adapted from Ch10 of Hackers Delight (hackersdelight.org).
    226          //
    227          //*****************************************************************************
    228          static uint64_t
    229          divu64_10(uint64_t ui64Val)
    230          {
    231              uint64_t q64, r64;
    232              uint32_t q32, r32, ui32Val;
    233          
    234              //
    235              // If a 32-bit value, use the more optimal 32-bit routine.
    236              //
    237              if ( ui64Val >> 32 )
    238              {
    239                  q64 = (ui64Val>>1) + (ui64Val>>2);
    240                  q64 += (q64 >> 4);
    241                  q64 += (q64 >> 8);
    242                  q64 += (q64 >> 16);
    243                  q64 += (q64 >> 32);
    244                  q64 >>= 3;
    245                  r64 = ui64Val - q64*10;
    246                  return q64 + ((r64 + 6) >> 4);
    247              }
    248              else
    249              {
    250                  ui32Val = (uint32_t)(ui64Val & 0xffffffff);
    251                  q32 = (ui32Val>>1) + (ui32Val>>2);
    252                  q32 += (q32 >> 4);
    253                  q32 += (q32 >> 8);
    254                  q32 += (q32 >> 16);
    255                  q32 >>= 3;
    256                  r32 = ui32Val - q32*10;
    257                  return (uint64_t)(q32 + ((r32 + 6) >> 4));
    258              }
    259          }
    260          
    261          //*****************************************************************************
    262          //
    263          // Return the number of decimal digits in an uint64_t.
    264          //
    265          // example: 10000 return 5, 123 returns 3.
    266          //
    267          //*****************************************************************************
    268          static int
    269          ndigits_in_u64(uint64_t ui64Val)
    270          {
    271              int iNDigits = ui64Val ? 0 : 1;
    272          
    273              while ( ui64Val )
    274              {
    275                  //
    276                  // ui32Val /= 10;
    277                  //
    278                  ui64Val = divu64_10(ui64Val);
    279                  ++iNDigits;
    280              }
    281          
    282              return iNDigits;
    283          }
    284          
    285          //*****************************************************************************
    286          //
    287          // Return the number of decimal digits in a 64-bit integer.
    288          //
    289          // Note: Does not include the '-' sign.
    290          //
    291          // example: -3 returns 1, 3 returns 1, 15 returns 2, -15 returns 2, ...
    292          //
    293          //*****************************************************************************
    294          static int
    295          ndigits_in_i64(int64_t i64Val)
    296          {
    297              if ( i64Val < 0 )
    298              {
    299                  //
    300                  // Get absolute value
    301                  //
    302                  i64Val = -i64Val;
    303              }
    304          
    305              return ndigits_in_u64((uint64_t) i64Val);
    306          }
    307          
    308          //*****************************************************************************
    309          //
    310          // Return the number of hex digits in an uint64_t.
    311          //
    312          //*****************************************************************************
    313          static int
    314          ndigits_in_hex(uint64_t ui64Val)
    315          {
    316              int iDigits = ui64Val ? 0 : 1;
    317          
    318              while ( ui64Val )
    319              {
    320                  ui64Val >>= 4;
    321                  ++iDigits;
    322              }
    323          
    324              return iDigits;
    325          }
    326          
    327          //*****************************************************************************
    328          //
    329          // Converts a string representing a decimal value to an int32_t.
    330          //
    331          // Returns the int32_t integer value.
    332          //
    333          // Note: If a count of the number of chars is desired, then provide
    334          // pui32CharCnt.
    335          //
    336          //*****************************************************************************
    337          static uint32_t
    338          decstr_to_int(const char *pcStr, uint32_t *pui32CharCnt)
    339          {
    340              bool bNeg = false;
    341              uint32_t ui32Val = 0, uCnt = 0;
    342          
    343              if ( *pcStr == '-')
    344              {
    345                  bNeg = true;
    346                  pcStr++;
    347                  uCnt++;
    348              }
    349          
    350              while ( *pcStr >= '0'  &&  *pcStr <= '9' )
    351              {
    352                  ++uCnt;
    353          
    354                  //
    355                  // Multiply accumulated value by 10.
    356                  //
    357                  ui32Val *= 10;
    358          
    359                  //
    360                  // Add in the new low digit.
    361                  //
    362                  ui32Val += (*pcStr - '0');
    363                  pcStr++;
    364              }
    365          
    366              if ( pui32CharCnt )
    367              {
    368                  *pui32CharCnt = uCnt;
    369              }
    370          
    371              return bNeg ? -ui32Val : ui32Val;
    372          }
    373          
    374          //*****************************************************************************
    375          //
    376          // Converts ui64Val to a string.
    377          // Note: pcBuf[] must be sized for a minimum of 21 characters.
    378          //
    379          // Returns the number of decimal digits in the string.
    380          //
    381          // NOTE: If pcBuf is NULL, will compute a return ui64Val only (no chars
    382          // written).
    383          //
    384          //*****************************************************************************
    385          static int
    386          uint64_to_str(uint64_t ui64Val, char *pcBuf)
    387          {
    388              char tbuf[25];
    389              int ix = 0, iNumDig = 0;
    390              unsigned uMod;
    391              uint64_t u64Tmp;
    392          
    393              do
    394              {
    395                  //
    396                  // Divide by 10
    397                  //
    398                  u64Tmp = divu64_10(ui64Val);
    399          
    400                  //
    401                  // Get modulus
    402                  //
    403                  uMod = ui64Val - (u64Tmp * 10);
    404          
    405                  tbuf[ix++] = uMod + '0';
    406                  ui64Val = u64Tmp;
    407              } while ( ui64Val );
    408          
    409              //
    410              // Save the total number of digits
    411              //
    412              iNumDig = ix;
    413          
    414              //
    415              // Now, reverse the buffer when saving to the caller's buffer.
    416              //
    417              if ( pcBuf )
    418              {
    419                  while ( ix-- )
    420                  {
    421                      *pcBuf++ = tbuf[ix];
    422                  }
    423          
    424                  //
    425                  // Terminate the caller's buffer
    426                  //
    427                  *pcBuf = 0x00;
    428              }
    429          
    430              return iNumDig;
    431          }
    432          
    433          //*****************************************************************************
    434          //
    435          // Converts ui64Val to a hex string.  Alpha chars are lower case.
    436          // Input:
    437          //  ui64Val = Value to be converted.
    438          //  pcBuf[] must be sized for a minimum of 17 characters.
    439          //
    440          // Returns the number of hex digits required for ui64Val (does not
    441          //  include the terminating NULL char in the string).
    442          //
    443          // NOTE: If pcBuf is NULL, will compute a return value only (no chars
    444          // written).
    445          //
    446          //*****************************************************************************
    447          static int
    448          uint64_to_hexstr(uint64_t ui64Val, char *pcBuf, bool bLower)
    449          {
    450              int iNumDig, ix = 0;
    451              char cCh, tbuf[20];
    452          
    453              if ( ui64Val == 0 )
    454              {
    455                  tbuf[ix++] = '0';   // Print a '0'
    456              }
    457          
    458              while ( ui64Val )
    459              {
    460                  cCh = ui64Val & 0xf;
    461          
    462                  //
    463                  // Alpha character
    464                  //
    465                  if ( cCh > 9 )
    466                  {
    467                      cCh += bLower ? 0x27 : 0x7;
    468                  }
    469          
    470                  tbuf[ix++] = cCh + '0';
    471                  ui64Val >>= 4;
    472              }
    473          
    474              //
    475              // Save the total number of digits
    476              //
    477              iNumDig = ix;
    478          
    479              //
    480              // Now, reverse the buffer when saving to the callers buffer.
    481              //
    482              if (pcBuf)
    483              {
    484                  while (ix--)
    485                  {
    486                      *pcBuf++ = tbuf[ix];
    487                  }
    488          
    489                  //
    490                  // Terminate the caller's buffer
    491                  //
    492                  *pcBuf = 0;
    493              }
    494          
    495              return iNumDig;
    496          }
    497          
    498          //*****************************************************************************
    499          //
    500          // Return length of the given string.
    501          //
    502          //*****************************************************************************
    503          static uint32_t
    504          simple_strlen(char *pcBuf)
    505          {
    506              uint32_t ui32RetVal = 0;
    507              if ( !pcBuf )
    508              {
    509                  return ui32RetVal;
    510              }
    511          
    512              while ( *pcBuf++ )
    513              {
    514                  ui32RetVal++;
    515              }
    516              return ui32RetVal;
    517          }
    518          
    519          //*****************************************************************************
    520          //
    521          // Pad a string buffer with pad characters.
    522          //
    523          //*****************************************************************************
    524          static int32_t
    525          padbuffer(char *pcBuf, uint8_t cPadChar, int32_t i32NumChars)
    526          {
    527              int32_t i32Cnt = 0;
    528          
    529              if ( i32NumChars <= 0 )
    530              {
    531                  return i32Cnt;
    532              }
    533          
    534              while ( i32NumChars-- )
    535              {
    536                  if ( pcBuf )
    537                  {
    538                      *pcBuf++ = cPadChar;
    539                  }
    540                  i32Cnt++;
    541              }
    542          
    543              return i32Cnt;
    544          }
    545          
    546          //*****************************************************************************
    547          //
    548          //! @brief Text mode translates linefeed (\n) characters to carriage return/
    549          //! linefeed (CR/LF) combinations in printf() and sprintf() functions.
    550          //!
    551          //! @param bSetTextTranslationMode - true: Do LF to CR/LF translation.
    552          //! false: Don't do the text mode translation.
    553          //!
    554          //! This function causes the printf() and sprintf() functions to translate
    555          //! newline characters (\\n) into CR/LF (\\r\\n) combinations.
    556          //!
    557          //! @return Previous mode.
    558          //
    559          //*****************************************************************************
    560          bool
    561          am_util_stdio_textmode_set(bool bSetTextTranslationMode)
    562          {
    563              bool bRet = g_bTxtXlate;
    564          
    565              //
    566              // true=cvt LF chars to CR/LF
    567              //
    568              g_bTxtXlate = bSetTextTranslationMode;
    569          
    570              //
    571              // return previous mode.
    572              //
    573              return bRet;
    574          }
    575          
    576          //*****************************************************************************
    577          //
    578          //  Float to ASCII text. A basic implementation for providing support for
    579          //  single-precision %f.
    580          //
    581          //  param
    582          //      fValue     = Float value to be converted.
    583          //      pcBuf      = Buffer to place string AND input of buffer size.
    584          //      iPrecision = Desired number of decimal places.
    585          //      IMPORTANT: On entry, the first 32-bit word of pcBuf must
    586          //                 contain the size (in bytes) of the buffer!
    587          //                 The recommended size is at least 16 bytes.
    588          //
    589          //  This function performs a basic translation of a floating point single
    590          //  precision value to a string.
    591          //
    592          //  return Number of chars printed to the buffer.
    593          //
    594          //*****************************************************************************
    595          #define AM_FTOA_ERR_VAL_TOO_SMALL   -1
    596          #define AM_FTOA_ERR_VAL_TOO_LARGE   -2
    597          #define AM_FTOA_ERR_BUFSIZE         -3
    598          
    599          typedef union
    600          {
    601              int32_t I32;
    602              float F;
    603          } i32fl_t;
    604          
    605          static int ftoa(float fValue, char *pcBuf, int iPrecision)
    606          {
    607              i32fl_t unFloatValue;
    608              int iExp2, iBufSize;
    609              int32_t i32Significand, i32IntPart, i32FracPart;
    610              char *pcBufInitial, *pcBuftmp;
    611          
    612              iBufSize = *(uint32_t*)pcBuf;
    613              if (iBufSize < 4)
    614              {
    615                  return AM_FTOA_ERR_BUFSIZE;
    616              }
    617          
    618              if (fValue == 0.0f)
    619              {
    620                  // "0.0"
    621                  *(uint32_t*)pcBuf = 0x00 << 24 | ('0' << 16) | ('.' << 8) | ('0' << 0);
    622                  return 3;
    623              }
    624          
    625              pcBufInitial = pcBuf;
    626          
    627              unFloatValue.F = fValue;
    628          
    629              iExp2 = ((unFloatValue.I32 >> 23) & 0x000000FF) - 127;
    630              i32Significand = (unFloatValue.I32 & 0x00FFFFFF) | 0x00800000;
    631              i32FracPart = 0;
    632              i32IntPart = 0;
    633          
    634              if (iExp2 >= 31)
    635              {
    636                  return AM_FTOA_ERR_VAL_TOO_LARGE;
    637              }
    638              else if (iExp2 < -23)
    639              {
    640                  return AM_FTOA_ERR_VAL_TOO_SMALL;
    641              }
    642              else if (iExp2 >= 23)
    643              {
    644                  i32IntPart = i32Significand << (iExp2 - 23);
    645              }
    646              else if (iExp2 >= 0)
    647              {
    648                  i32IntPart = i32Significand >> (23 - iExp2);
    649                  i32FracPart = (i32Significand << (iExp2 + 1)) & 0x00FFFFFF;
    650              }
    651              else // if (iExp2 < 0)
    652              {
    653                  i32FracPart = (i32Significand & 0x00FFFFFF) >> -(iExp2 + 1);
    654              }
    655          
    656              if (unFloatValue.I32 < 0)
    657              {
    658                  *pcBuf++ = '-';
    659              }
    660          
    661              if (i32IntPart == 0)
    662              {
    663                  *pcBuf++ = '0';
    664              }
    665              else
    666              {
    667                  if (i32IntPart > 0)
    668                  {
    669                      uint64_to_str(i32IntPart, pcBuf);
    670                  }
    671                  else
    672                  {
    673                      *pcBuf++ = '-';
    674                      uint64_to_str(-i32IntPart, pcBuf);
    675                  }
    676                  while (*pcBuf)    // Get to end of new string
    677                  {
    678                      pcBuf++;
    679                  }
    680              }
    681          
    682              //
    683              // Now, begin the fractional part
    684              //
    685              *pcBuf++ = '.';
    686          
    687              if (i32FracPart == 0)
    688              {
    689                  *pcBuf++ = '0';
    690              }
    691              else
    692              {
    693                  int jx, iMax;
    694          
    695                  iMax = iBufSize - (pcBuf - pcBufInitial) - 1;
    696                  iMax = (iMax > iPrecision) ? iPrecision : iMax;
    697          
    698                  for (jx = 0; jx < iMax; jx++)
    699                  {
    700                      i32FracPart *= 10;
    701                      *pcBuf++ = (i32FracPart >> 24) + '0';
    702                      i32FracPart &= 0x00FFFFFF;
    703                  }
    704          
    705                  //
    706                  // Per the printf spec, the number of digits printed to the right of the
    707                  // decimal point (i.e. iPrecision) should be rounded.
    708                  // Some examples:
    709                  // Value        iPrecision          Formatted value
    710                  // 1.36399      Unspecified (6)     1.363990
    711                  // 1.36399      3                   1.364
    712                  // 1.36399      4                   1.3640
    713                  // 1.36399      5                   1.36399
    714                  // 1.363994     Unspecified (6)     1.363994
    715                  // 1.363994     3                   1.364
    716                  // 1.363994     4                   1.3640
    717                  // 1.363994     5                   1.36399
    718                  // 1.363995     Unspecified (6)     1.363995
    719                  // 1.363995     3                   1.364
    720                  // 1.363995     4                   1.3640
    721                  // 1.363995     5                   1.36400
    722                  // 1.996        Unspecified (6)     1.996000
    723                  // 1.996        2                   2.00
    724                  // 1.996        3                   1.996
    725                  // 1.996        4                   1.9960
    726                  //
    727                  // To determine whether to round up, we'll look at what the next
    728                  // decimal value would have been.
    729                  //
    730                  if ( ((i32FracPart * 10) >> 24) >= 5 )
    731                  {
    732                      //
    733                      // Yes, we need to round up.
    734                      // Go back through the string and make adjustments as necessary.
    735                      //
    736                      pcBuftmp = pcBuf - 1;
    737                      while ( pcBuftmp >= pcBufInitial )
    738                      {
    739                          if ( *pcBuftmp == '.' )
    740                          {
    741                          }
    742                          else if ( *pcBuftmp == '9' )
    743                          {
    744                              *pcBuftmp = '0';
    745                          }
    746                          else
    747                          {
    748                              *pcBuftmp += 1;
    749                              break;
    750                          }
    751                          pcBuftmp--;
    752                      }
    753                  }
    754              }
    755          
    756              //
    757              // Terminate the string and we're done
    758              //
    759              *pcBuf = 0x00;
    760          
    761              return (pcBuf - pcBufInitial);
    762          } // ftoa()
    763          
    764          //******************************************************************************
    765          //
    766          //! @brief Format data into string. (va_list implementation)
    767          //!
    768          //! @param *pcBuf - Pointer to the buffer to store the string
    769          //! @param *pcFmt - Pointer to formatter string
    770          //!
    771          //! A lite version of vsprintf().
    772          //!      Currently handles the following specifiers:
    773          //!      %c
    774          //!      %s
    775          //!      %[0][width]d (also %i)
    776          //!      %[0][width]u
    777          //!      %[0][width]x
    778          //!      %[.precision]f
    779          //!
    780          //!     Note than any unrecognized or unhandled format specifier character is
    781          //!     simply printed.  For example, "%%" will print a '%' character.
    782          //!
    783          //! @return uint32_t representing the number of characters printed.
    784          //
    785          //******************************************************************************
    786          uint32_t
    787          am_util_stdio_vsprintf(char *pcBuf, const char *pcFmt, va_list pArgs)
    788          {
    789              char *pcStr;
    790              uint64_t ui64Val;
    791              int64_t i64Val;
    792              uint32_t ui32NumChars, ui32CharCnt = 0;
    793              int iWidth, iVal, iPrecision;
    794              uint8_t ui8CharSpecifier, ui8PadChar;
    795              bool bLower, bLongLong, bNeg;
    796              uint32_t ui32strlen = 0;
    797          
    798              while ( *pcFmt != 0x0 )
    799              {
    800                  iPrecision = 6;             // printf() default precision for %f is 6
    801          
    802                  if ( *pcFmt != '%' )
    803                  {
    804                      //
    805                      // Accumulate the string portion of the format specification.
    806                      //
    807                      if ( pcBuf )
    808                      {
    809                          // If '\n', convert to '\r\n'
    810                          if ( *pcFmt == '\n'  &&  g_bTxtXlate )
    811                          {
    812                              *pcBuf++ = '\r';
    813                              ++ui32CharCnt;
    814                          }
    815                          *pcBuf++ = *pcFmt;
    816                      }
    817          
    818                      ++pcFmt;
    819                      ++ui32CharCnt;
    820                      continue;
    821                  }
    822          
    823                  //
    824                  // Handle the specifier.
    825                  //
    826                  ++pcFmt;
    827                  bLower = bLongLong = false;
    828          
    829                  //
    830                  // Default to space as ui8PadChar
    831                  //
    832                  ui8PadChar = ' ';
    833          
    834                  if ( *pcFmt == '0' )
    835                  {
    836                      ui8PadChar = '0';
    837                      ++pcFmt;
    838                  }
    839          
    840                  //
    841                  // Width specifier
    842                  //
    843                  iWidth = decstr_to_int(pcFmt, &ui32NumChars);
    844                  pcFmt += ui32NumChars;
    845          
    846                  //
    847                  // For now, only support a negative width specifier for %s
    848                  //
    849                  if ( ( *pcFmt != 's' )  &&  ( iWidth < 0 ) )
    850                  {
    851                      iWidth = -iWidth;
    852                  }
    853          
    854                  //
    855                  // Check for precision specifier
    856                  //
    857                  if (*pcFmt == '.')
    858                  {
    859                      ++pcFmt;
    860                      iPrecision = decstr_to_int(pcFmt, &ui32NumChars);
    861                      pcFmt += ui32NumChars;
    862                  }
    863          
    864                  //
    865                  // Check for the long or long long length field sub-specifiers, 'l' or
    866                  // 'll', which must be a modifier for either 'd', 'i', 'u', 'x', or 'X'
    867                  // (or even 'o', which is not currently supported). Other sub-specifiers
    868                  // like 'hh','h', etc. are not currently handled.
    869                  // Note - 'l' is used in Coremark, a primary reason it's supported here.
    870                  //
    871                  if ( *pcFmt == 'l' )
    872                  {
    873                      pcFmt++;
    874                      if ( *pcFmt == 'l' )    // "ll" (long long)
    875                      {
    876                          pcFmt++;
    877                          bLongLong = true;
    878                      }
    879                  }
    880          
    881                  switch ( *pcFmt )
    882                  {
    883                      case 'c':
    884                          ui8CharSpecifier = va_arg(pArgs, uint32_t);
    885          
    886                          if ( pcBuf )
    887                          {
    888                              *pcBuf++ = ui8CharSpecifier;
    889                          }
    890          
    891                          ++ui32CharCnt;
    892                          break;
    893          
    894                      case 's':
    895                          pcStr = va_arg(pArgs, char *);
    896          
    897                          //
    898                          // For %s, we support the width specifier. If iWidth is negative
    899                          // the string is left-aligned (padding on the right).  Otherwise
    900                          // the string is padded at the beginning with spaces.
    901                          //
    902                          ui32strlen = simple_strlen(pcStr);
    903                          if ( iWidth > 0 )
    904                          {
    905                              // Pad the beginning of the string (right-aligned).
    906                              if ( ui32strlen < iWidth )
    907                              {
    908                                  // String needs some padding.
    909                                  iWidth -= ui32strlen;
    910                                  iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    911                                  pcBuf += pcBuf ? iWidth : 0;
    912                                  ui32CharCnt += iWidth;
    913                                  iWidth = 0;
    914                              }
    915                          }
    916          
    917                          while (*pcStr != 0x0)
    918                          {
    919                              if ( pcBuf )
    920                              {
    921                                  *pcBuf++ = *pcStr;
    922                              }
    923          
    924                              ++pcStr;
    925                              ++ui32CharCnt;
    926                          }
    927          
    928                          if ( iWidth )
    929                          {
    930                              iWidth = -iWidth;
    931          
    932                              // Pad the end of the string (left-aligned).
    933                              if ( ui32strlen < iWidth )
    934                              {
    935                                  // String needs some padding.
    936                                  iWidth -= ui32strlen;
    937                                  iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    938                                  pcBuf += pcBuf ? iWidth : 0;
    939                                  ui32CharCnt += iWidth;
    940                                  iWidth = 0;
    941                              }
    942                          }
    943                          break;
    944          
    945                      case 'x':
    946                          bLower = true;
    947                      case 'X':
    948                          ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    949                                                va_arg(pArgs, uint32_t);
    950          
    951                          if ( iWidth )
    952                          {
    953                              //
    954                              // Compute # of leading chars
    955                              //
    956                              iWidth -= ndigits_in_hex(ui64Val);
    957          
    958                              iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    959                              pcBuf += pcBuf ? iWidth : 0;
    960                              ui32CharCnt += iWidth;
    961                              iWidth = 0;
    962                          }
    963          
    964                          iVal = uint64_to_hexstr(ui64Val, pcBuf, bLower);
    965          
    966                          if ( pcBuf )
    967                          {
    968                              pcBuf += iVal;
    969                          }
    970          
    971                          ui32CharCnt += iVal;
    972                          break;
    973          
    974                      case 'u':
    975                          ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
    976                                                va_arg(pArgs, uint32_t);
    977          
    978                          if ( iWidth )
    979                          {
    980                              //
    981                              // We need to pad the beginning of the value.
    982                              // Compute # of leading chars
    983                              //
    984                              iWidth -= ndigits_in_u64(ui64Val);
    985          
    986                              iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
    987                              pcBuf += pcBuf ? iWidth : 0;
    988                              ui32CharCnt += iWidth;
    989                              iWidth = 0;
    990                          }
    991          
    992                          iVal = uint64_to_str(ui64Val, pcBuf);
    993          
    994                          if ( pcBuf )
    995                          {
    996                              pcBuf += iVal;
    997                          }
    998          
    999                          ui32CharCnt += iVal;
   1000                          break;
   1001          
   1002                      case 'd':
   1003                      case 'i':
   1004                          //
   1005                          // Output for a negative number, for example, -5:
   1006                          //   %d:-5
   1007                          //  %5d:   -5
   1008                          // %05d:-0005
   1009                          //
   1010                          i64Val = bLongLong ? va_arg(pArgs, int64_t) :
   1011                                               va_arg(pArgs, int32_t);
   1012          
   1013                          //
   1014                          // Get absolute value
   1015                          //
   1016                          if ( i64Val < 0 )
   1017                          {
   1018                              ui64Val = -i64Val;          // Get absolute value
   1019                              bNeg = true;
   1020                          }
   1021                          else
   1022                          {
   1023                              ui64Val = i64Val;
   1024                              bNeg = false;
   1025                          }
   1026          
   1027                          if ( iWidth )
   1028                          {
   1029                              //
   1030                              // We need to pad the beginning of the value.
   1031                              // Compute # of leading chars
   1032                              //
   1033                              iWidth -= ndigits_in_i64(ui64Val);
   1034          
   1035                              if ( bNeg )
   1036                              {
   1037                                  --iWidth;
   1038          
   1039                                  //
   1040                                  // Allow for the negative sign
   1041                                  //
   1042                                  if ( ui8PadChar == '0' )
   1043                                  {
   1044                                      //
   1045                                      // Print the neg sign BEFORE the leading zeros
   1046                                      //
   1047                                      if ( pcBuf )
   1048                                      {
   1049                                          *pcBuf++ = '-';
   1050                                      }
   1051          
   1052                                      ++ui32CharCnt;
   1053                                  }
   1054                              }
   1055          
   1056                              iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
   1057                              pcBuf += pcBuf ? iWidth : 0;
   1058                              ui32CharCnt += iWidth;
   1059                              iWidth = 0;
   1060          
   1061                              if ( bNeg  &&  (ui8PadChar == ' ') )
   1062                              {
   1063                                  //
   1064                                  // Print the neg sign AFTER the leading blanks
   1065                                  //
   1066                                  if ( pcBuf )
   1067                                  {
   1068                                      *pcBuf++ = '-';
   1069                                  }
   1070          
   1071                                  ++ui32CharCnt;
   1072                              }
   1073                          }
   1074                          else
   1075                          {
   1076                              if ( bNeg )
   1077                              {
   1078                                  if ( pcBuf )
   1079                                  {
   1080                                      *pcBuf++ = '-';
   1081                                  }
   1082                                  ++ui32CharCnt;
   1083                              }
   1084                          }
   1085          
   1086                          iVal = uint64_to_str(ui64Val, pcBuf);
   1087          
   1088                          if ( pcBuf )
   1089                          {
   1090                              pcBuf += iVal;
   1091                          }
   1092          
   1093                          ui32CharCnt += iVal;
   1094                          break;
   1095          
   1096          
   1097                      case 'f':
   1098                      case 'F':
   1099                          if ( pcBuf )
   1100                          {
   1101                              float fValue = va_arg(pArgs, double);
   1102          
   1103                              //
   1104                              // pcBuf is an input (size of buffer) and also an output of ftoa()
   1105                              //
   1106                              *(uint32_t*)pcBuf = 20;
   1107          
   1108                              iVal = ftoa(fValue, pcBuf, iPrecision);
   1109                              if ( iVal < 0 )
   1110                              {
   1111                                  uint32_t u32PrntErrVal;
   1112                                  if ( iVal == AM_FTOA_ERR_VAL_TOO_SMALL )
   1113                                  {
   1114                                      u32PrntErrVal = (0x00 << 24) | ('0' << 16) |
   1115                                                      ('.' << 8)   | ('0' << 0);  // "0.0"
   1116                                  }
   1117                                  else if ( iVal == AM_FTOA_ERR_VAL_TOO_LARGE )
   1118                                  {
   1119                                      u32PrntErrVal = (0x00 << 24) | ('#' << 16) |
   1120                                                      ('.' << 8)   | ('#' << 0);  // "#.#"
   1121                                  }
   1122                                  else
   1123                                  {
   1124                                      u32PrntErrVal = (0x00 << 24) | ('?' << 16) |
   1125                                                      ('.' << 8)   | ('?' << 0);  // "?.?"
   1126                                  }
   1127                                  *(uint32_t*)pcBuf = u32PrntErrVal;
   1128                                  iVal = 3;
   1129                              }
   1130                              ui32CharCnt += iVal;
   1131                              pcBuf += iVal;
   1132                          }
   1133                          break;
   1134          
   1135                      //
   1136                      // Invalid specifier character
   1137                      // For non-handled specifiers, we'll just print the character.
   1138                      // e.g. this will allow the normal printing of a '%' using
   1139                      // "%%".
   1140                      //
   1141                      default:
   1142                          if ( pcBuf )
   1143                          {
   1144                              *pcBuf++ = *pcFmt;
   1145                          }
   1146          
   1147                          ++ui32CharCnt;
   1148                          break;
   1149          
   1150                  } // switch()
   1151          
   1152                  //
   1153                  // Bump the format specification to the next character
   1154                  //
   1155                  ++pcFmt;
   1156          
   1157              } // while ()
   1158          
   1159              //
   1160              // Terminate the string
   1161              //
   1162              if ( pcBuf )
   1163              {
   1164                  *pcBuf = 0x0;
   1165              }
   1166          
   1167              return (ui32CharCnt);
   1168          }
   1169          
   1170          //******************************************************************************
   1171          //
   1172          //! @brief Format data into string.
   1173          //!
   1174          //! @param *pcBuf - Pointer to the buffer to store the string
   1175          //! @param *pcFmt - Pointer to formater string
   1176          //!
   1177          //! A lite version of vsprintf().
   1178          //!      Currently handles the following specifiers:
   1179          //!      %c
   1180          //!      %s
   1181          //!      %[0][width]d (also %i)
   1182          //!      %[0][width]u
   1183          //!      %[0][width]x
   1184          //!
   1185          //!     Note than any unrecognized or unhandled format specifier character is
   1186          //!     simply printed.  For example, "%%" will print a '%' character.
   1187          //!
   1188          //! @return uint32_t representing the number of characters printed.
   1189          //
   1190          //******************************************************************************
   1191          uint32_t
   1192          am_util_stdio_sprintf(char *pcBuf, const char *pcFmt, ...)
   1193          {
   1194              uint32_t ui32CharCnt;
   1195          
   1196              va_list pArgs;
   1197              va_start(pArgs, pcFmt);
   1198              ui32CharCnt = am_util_stdio_vsprintf(pcBuf, pcFmt, pArgs);
   1199              va_end(pArgs);
   1200          
   1201              return ui32CharCnt;
   1202          }
   1203          
   1204          //*****************************************************************************
   1205          //
   1206          //! @brief A lite version of printf()
   1207          //!
   1208          //! @param *pcFmt - Pointer to formatter string
   1209          //!
   1210          //!  See am_util_stdio_sprintf() for more details.
   1211          //!
   1212          //! @return uint32_t representing the number of characters printed.
   1213          //
   1214          // *****************************************************************************
   1215          uint32_t
   1216          am_util_stdio_printf(const char *pcFmt, ...)
   1217          {
   1218              uint32_t ui32NumChars;
   1219          
   1220              if (!g_pfnCharPrint)
   1221              {
   1222                  return 0;
   1223              }
   1224          
   1225              //
   1226              // Convert to the desired string.
   1227              //
   1228              va_list pArgs;
   1229              va_start(pArgs, pcFmt);
   1230              ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
   1231              va_end(pArgs);
   1232          
   1233              //
   1234              // This is where we print the buffer to the configured interface.
   1235              //
   1236              g_pfnCharPrint(g_prfbuf);
   1237          
   1238              //
   1239              // return the number of characters printed.
   1240              //
   1241              return ui32NumChars;
   1242          }
   1243          
   1244          //*****************************************************************************
   1245          //
   1246          //! @brief Clear the terminal screen
   1247          //!
   1248          //! This function clears a standard terminal screen.
   1249          //!
   1250          //! @return None.
   1251          //
   1252          //*****************************************************************************
   1253          void
   1254          am_util_stdio_terminal_clear(void)
   1255          {
   1256              //
   1257              // Escape codes to clear a terminal screen and put the cursor in the top
   1258              // left corner.
   1259              // We'll first print a number of spaces, which helps get the ITM in sync
   1260              // with AM Flash, especially after a reset event or a system clock
   1261              // frequency change.
   1262              //
   1263              am_util_stdio_printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
   1264          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   am_util_stdio_printf
        24   -- Indirect call
        24   -> am_util_stdio_vsprintf
       0   am_util_stdio_printf_init
      16   am_util_stdio_sprintf
        16   -> am_util_stdio_vsprintf
      12   am_util_stdio_strtoul
       0   am_util_stdio_terminal_clear
         0   -> am_util_stdio_printf
       0   am_util_stdio_textmode_set
     112   am_util_stdio_vsprintf
       112   -> __aeabi_d2f


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
      20  ?_0
      36  am_util_stdio_printf
       6  am_util_stdio_printf_init
      18  am_util_stdio_sprintf
     114  am_util_stdio_strtoul
       4  am_util_stdio_terminal_clear
      12  am_util_stdio_textmode_set
   3'158  am_util_stdio_vsprintf
       1  g_bTxtXlate
     260  g_pfnCharPrint
          g_prfbuf

 
   261 bytes in section .bss
 3'392 bytes in section .text
 
 3'392 bytes of CODE memory
   261 bytes of DATA memory

Errors: none
Warnings: none
