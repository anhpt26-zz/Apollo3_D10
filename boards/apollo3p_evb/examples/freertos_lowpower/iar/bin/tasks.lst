###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.6.265/W32 for ARM         07/Jul/2021  16:12:37
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        X:\Documents\Apollo3\A3_SDK\third_party\FreeRTOSv10.1.1\Source\tasks.c
#    Command line                 =
#        -f C:\Users\ADMINI~1\AppData\Local\Temp\EWCF69.tmp
#        (X:\Documents\Apollo3\A3_SDK\third_party\FreeRTOSv10.1.1\Source\tasks.c
#        -D iar -D AM_PART_APOLLO3P -D AM_DEBUG_PRINTF -D AM_FREERTOS -D
#        AM_PACKAGE_BGA -D AM_UTIL_FAULTISR_PRINT -lcN
#        X:\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_lowpower\iar\bin
#        --diag_suppress Pa050 -o
#        X:\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_lowpower\iar\bin
#        --debug --endian=little --cpu=Cortex-M4 --no_path_in_file_macros -e
#        --fpu=VFPv4_sp --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        X:\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_lowpower\iar\..\..\..\..\..\third_party\FreeRTOSv10.1.1\Source\portable\IAR\AMapollo2\\
#        -I
#        X:\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_lowpower\iar\..\src\\
#        -I
#        X:\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_lowpower\iar\..\..\..\..\..\\
#        -I
#        X:\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_lowpower\iar\..\..\..\..\..\CMSIS\ARM\Include\\
#        -I
#        X:\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_lowpower\iar\..\..\..\..\..\CMSIS\AmbiqMicro\Include\\
#        -I
#        X:\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_lowpower\iar\..\..\..\bsp\\
#        -I
#        X:\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_lowpower\iar\..\..\..\..\..\mcu\apollo3p\\
#        -I
#        X:\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_lowpower\iar\..\..\..\..\..\devices\\
#        -I
#        X:\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_lowpower\iar\..\..\..\..\..\utils\\
#        -I
#        X:\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_lowpower\iar\..\..\..\..\..\third_party\FreeRTOSv10.1.1\Source\include\\
#        -Ohs --no_size_constraints)
#    Locale                       =  C
#    List file                    =
#        X:\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_lowpower\iar\bin\tasks.lst
#    Object file                  =
#        X:\Documents\Apollo3\A3_SDK\boards\apollo3p_evb\examples\freertos_lowpower\iar\bin\tasks.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#
###############################################################################

X:\Documents\Apollo3\A3_SDK\third_party\FreeRTOSv10.1.1\Source\tasks.c
      1          /*
      2           * FreeRTOS Kernel V10.1.1
      3           * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
      4           *
      5           * Permission is hereby granted, free of charge, to any person obtaining a copy of
      6           * this software and associated documentation files (the "Software"), to deal in
      7           * the Software without restriction, including without limitation the rights to
      8           * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
      9           * the Software, and to permit persons to whom the Software is furnished to do so,
     10           * subject to the following conditions:
     11           *
     12           * The above copyright notice and this permission notice shall be included in all
     13           * copies or substantial portions of the Software.
     14           *
     15           * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     16           * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
     17           * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
     18           * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
     19           * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
     20           * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     21           *
     22           * http://www.FreeRTOS.org
     23           * http://aws.amazon.com/freertos
     24           *
     25           * 1 tab == 4 spaces!
     26           */
     27          
     28          /* Standard includes. */
     29          #include <stdlib.h>
     30          #include <string.h>
     31          
     32          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     33          all the API functions to use the MPU wrappers.  That should only be done when
     34          task.h is included from an application file. */
     35          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     36          
     37          /* FreeRTOS includes. */
     38          #include "FreeRTOS.h"
     39          #include "task.h"
     40          #include "timers.h"
     41          #include "stack_macros.h"
     42          
     43          /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
     44          because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
     45          for the header files above, but not in this file, in order to generate the
     46          correct privileged Vs unprivileged linkage and placement. */
     47          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
     48          
     49          /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
     50          functions but without including stdio.h here. */
     51          #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
     52          	/* At the bottom of this file are two optional functions that can be used
     53          	to generate human readable text from the raw data generated by the
     54          	uxTaskGetSystemState() function.  Note the formatting functions are provided
     55          	for convenience only, and are NOT considered part of the kernel. */
     56          	#include <stdio.h>
     57          #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
     58          
     59          #if( configUSE_PREEMPTION == 0 )
     60          	/* If the cooperative scheduler is being used then a yield should not be
     61          	performed just because a higher priority task has been woken. */
     62          	#define taskYIELD_IF_USING_PREEMPTION()
     63          #else
     64          	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
     65          #endif
     66          
     67          /* Values that can be assigned to the ucNotifyState member of the TCB. */
     68          #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
     69          #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
     70          #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
     71          
     72          /*
     73           * The value used to fill the stack of a task when the task is created.  This
     74           * is used purely for checking the high water mark for tasks.
     75           */
     76          #define tskSTACK_FILL_BYTE	( 0xa5U )
     77          
     78          /* Sometimes the FreeRTOSConfig.h settings only allow a task to be created using
     79          dynamically allocated RAM, in which case when any task is deleted it is known
     80          that both the task's stack and TCB need to be freed.  Sometimes the
     81          FreeRTOSConfig.h settings only allow a task to be created using statically
     82          allocated RAM, in which case when any task is deleted it is known that neither
     83          the task's stack or TCB should be freed.  Sometimes the FreeRTOSConfig.h
     84          settings allow a task to be created using either statically or dynamically
     85          allocated RAM, in which case a member of the TCB is used to record whether the
     86          stack and/or TCB were allocated statically or dynamically, so when a task is
     87          deleted the RAM that was allocated dynamically is freed again and no attempt is
     88          made to free the RAM that was allocated statically.
     89          tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is only true if it is possible for a
     90          task to be created using either statically or dynamically allocated RAM.  Note
     91          that if portUSING_MPU_WRAPPERS is 1 then a protected task can be created with
     92          a statically allocated stack and a dynamically allocated TCB.
     93          !!!NOTE!!! If the definition of tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is
     94          changed then the definition of StaticTask_t must also be updated. */
     95          #define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE	( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
     96          #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
     97          #define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
     98          #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
     99          
    100          /* If any of the following are set then task stacks are filled with a known
    101          value so the high water mark can be determined.  If none of the following are
    102          set then don't fill the stack so there is no unnecessary dependency on memset. */
    103          #if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
    104          	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	1
    105          #else
    106          	#define tskSET_NEW_STACKS_TO_KNOWN_VALUE	0
    107          #endif
    108          
    109          /*
    110           * Macros used by vListTask to indicate which state a task is in.
    111           */
    112          #define tskRUNNING_CHAR		( 'X' )
    113          #define tskBLOCKED_CHAR		( 'B' )
    114          #define tskREADY_CHAR		( 'R' )
    115          #define tskDELETED_CHAR		( 'D' )
    116          #define tskSUSPENDED_CHAR	( 'S' )
    117          
    118          /*
    119           * Some kernel aware debuggers require the data the debugger needs access to be
    120           * global, rather than file scope.
    121           */
    122          #ifdef portREMOVE_STATIC_QUALIFIER
    123          	#define static
    124          #endif
    125          
    126          /* The name allocated to the Idle task.  This can be overridden by defining
    127          configIDLE_TASK_NAME in FreeRTOSConfig.h. */
    128          #ifndef configIDLE_TASK_NAME
    129          	#define configIDLE_TASK_NAME "IDLE"
    130          #endif
    131          
    132          #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
    133          
    134          	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
    135          	performed in a generic way that is not optimised to any particular
    136          	microcontroller architecture. */
    137          
    138          	/* uxTopReadyPriority holds the priority of the highest priority ready
    139          	state task. */
    140          	#define taskRECORD_READY_PRIORITY( uxPriority )														\
    141          	{																									\
    142          		if( ( uxPriority ) > uxTopReadyPriority )														\
    143          		{																								\
    144          			uxTopReadyPriority = ( uxPriority );														\
    145          		}																								\
    146          	} /* taskRECORD_READY_PRIORITY */
    147          
    148          	/*-----------------------------------------------------------*/
    149          
    150          	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
    151          	{																									\
    152          	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
    153          																										\
    154          		/* Find the highest priority queue that contains ready tasks. */								\
    155          		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
    156          		{																								\
    157          			configASSERT( uxTopPriority );																\
    158          			--uxTopPriority;																			\
    159          		}																								\
    160          																										\
    161          		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
    162          		the	same priority get an equal share of the processor time. */									\
    163          		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
    164          		uxTopReadyPriority = uxTopPriority;																\
    165          	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
    166          
    167          	/*-----------------------------------------------------------*/
    168          
    169          	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
    170          	they are only required when a port optimised method of task selection is
    171          	being used. */
    172          	#define taskRESET_READY_PRIORITY( uxPriority )
    173          	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
    174          
    175          #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
    176          
    177          	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
    178          	performed in a way that is tailored to the particular microcontroller
    179          	architecture being used. */
    180          
    181          	/* A port optimised version is provided.  Call the port defined macros. */
    182          	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
    183          
    184          	/*-----------------------------------------------------------*/
    185          
    186          	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
    187          	{																								\
    188          	UBaseType_t uxTopPriority;																		\
    189          																									\
    190          		/* Find the highest priority list that contains ready tasks. */								\
    191          		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
    192          		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
    193          		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
    194          	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
    195          
    196          	/*-----------------------------------------------------------*/
    197          
    198          	/* A port optimised version is provided, call it only if the TCB being reset
    199          	is being referenced from a ready list.  If it is referenced from a delayed
    200          	or suspended list then it won't be in a ready list. */
    201          	#define taskRESET_READY_PRIORITY( uxPriority )														\
    202          	{																									\
    203          		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
    204          		{																								\
    205          			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
    206          		}																								\
    207          	}
    208          
    209          #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
    210          
    211          /*-----------------------------------------------------------*/
    212          
    213          /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
    214          count overflows. */
    215          #define taskSWITCH_DELAYED_LISTS()																	\
    216          {																									\
    217          	List_t *pxTemp;																					\
    218          																									\
    219          	/* The delayed tasks list should be empty when the lists are switched. */						\
    220          	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
    221          																									\
    222          	pxTemp = pxDelayedTaskList;																		\
    223          	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
    224          	pxOverflowDelayedTaskList = pxTemp;																\
    225          	xNumOfOverflows++;																				\
    226          	prvResetNextTaskUnblockTime();																	\
    227          }
    228          
    229          /*-----------------------------------------------------------*/
    230          
    231          /*
    232           * Place the task represented by pxTCB into the appropriate ready list for
    233           * the task.  It is inserted at the end of the list.
    234           */
    235          #define prvAddTaskToReadyList( pxTCB )																\
    236          	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
    237          	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
    238          	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) ); \
    239          	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
    240          /*-----------------------------------------------------------*/
    241          
    242          /*
    243           * Several functions take an TaskHandle_t parameter that can optionally be NULL,
    244           * where NULL is used to indicate that the handle of the currently executing
    245           * task should be used in place of the parameter.  This macro simply checks to
    246           * see if the parameter is NULL and returns a pointer to the appropriate TCB.
    247           */
    248          #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle ) )
    249          
    250          /* The item value of the event list item is normally used to hold the priority
    251          of the task to which it belongs (coded to allow it to be held in reverse
    252          priority order).  However, it is occasionally borrowed for other purposes.  It
    253          is important its value is not updated due to a task priority change while it is
    254          being used for another purpose.  The following bit definition is used to inform
    255          the scheduler that the value should not be changed - in which case it is the
    256          responsibility of whichever module is using the value to ensure it gets set back
    257          to its original value when it is released. */
    258          #if( configUSE_16_BIT_TICKS == 1 )
    259          	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
    260          #else
    261          	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
    262          #endif
    263          
    264          /*
    265           * Task control block.  A task control block (TCB) is allocated for each task,
    266           * and stores task state information, including a pointer to the task's context
    267           * (the task's run time environment, including register values)
    268           */
    269          typedef struct tskTaskControlBlock /* The old naming convention is used to prevent breaking kernel aware debuggers. */
    270          {
    271          	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
    272          
    273          	#if ( portUSING_MPU_WRAPPERS == 1 )
    274          		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
    275          	#endif
    276          
    277          	ListItem_t			xStateListItem;	/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
    278          	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
    279          	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
    280          	StackType_t			*pxStack;			/*< Points to the start of the stack. */
    281          	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    282          
    283          	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
    284          		StackType_t		*pxEndOfStack;		/*< Points to the highest valid address for the stack. */
    285          	#endif
    286          
    287          	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
    288          		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
    289          	#endif
    290          
    291          	#if ( configUSE_TRACE_FACILITY == 1 )
    292          		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
    293          		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. */
    294          	#endif
    295          
    296          	#if ( configUSE_MUTEXES == 1 )
    297          		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority inheritance mechanism. */
    298          		UBaseType_t		uxMutexesHeld;
    299          	#endif
    300          
    301          	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
    302          		TaskHookFunction_t pxTaskTag;
    303          	#endif
    304          
    305          	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
    306          		void			*pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
    307          	#endif
    308          
    309          	#if( configGENERATE_RUN_TIME_STATS == 1 )
    310          		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state. */
    311          	#endif
    312          
    313          	#if ( configUSE_NEWLIB_REENTRANT == 1 )
    314          		/* Allocate a Newlib reent structure that is specific to this task.
    315          		Note Newlib support has been included by popular demand, but is not
    316          		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
    317          		responsible for resulting newlib operation.  User must be familiar with
    318          		newlib and must provide system-wide implementations of the necessary
    319          		stubs. Be warned that (at the time of writing) the current newlib design
    320          		implements a system-wide malloc() that must be provided with locks. */
    321          		struct	_reent xNewLib_reent;
    322          	#endif
    323          
    324          	#if( configUSE_TASK_NOTIFICATIONS == 1 )
    325          		volatile uint32_t ulNotifiedValue;
    326          		volatile uint8_t ucNotifyState;
    327          	#endif
    328          
    329          	/* See the comments above the definition of
    330          	tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
    331          	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
    332          		uint8_t	ucStaticallyAllocated; 		/*< Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */
    333          	#endif
    334          
    335          	#if( INCLUDE_xTaskAbortDelay == 1 )
    336          		uint8_t ucDelayAborted;
    337          	#endif
    338          
    339          	#if( configUSE_POSIX_ERRNO == 1 )
    340          		int iTaskErrno;
    341          	#endif
    342          
    343          } tskTCB;
    344          
    345          /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
    346          below to enable the use of older kernel aware debuggers. */
    347          typedef tskTCB TCB_t;
    348          
    349          /*lint -save -e956 A manual analysis and inspection has been used to determine
    350          which static variables must be declared volatile. */
    351          PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
    352          
    353          /* Lists for ready and blocked tasks. --------------------
    354          xDelayedTaskList1 and xDelayedTaskList2 could be move to function scople but
    355          doing so breaks some kernel aware debuggers and debuggers that rely on removing
    356          the static qualifier. */
    357          PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks. */
    358          PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
    359          PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
    360          PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list currently being used. */
    361          PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
    362          PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
    363          
    364          #if( INCLUDE_vTaskDelete == 1 )
    365          
    366          	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but their memory not yet freed. */
    367          	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
    368          
    369          #endif
    370          
    371          #if ( INCLUDE_vTaskSuspend == 1 )
    372          
    373          	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
    374          
    375          #endif
    376          
    377          /* Global POSIX errno. Its value is changed upon context switching to match
    378          the errno of the currently running task. */
    379          #if ( configUSE_POSIX_ERRNO == 1 )
    380          	int FreeRTOS_errno = 0;
    381          #endif
    382          
    383          /* Other file private variables. --------------------------------*/
    384          PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
    385          PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) configINITIAL_TICK_COUNT;
    386          PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
    387          PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
    388          PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
    389          PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
    390          PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
    391          PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
    392          PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialised to portMAX_DELAY before the scheduler starts. */
    393          PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
    394          
    395          /* Context switches are held pending while the scheduler is suspended.  Also,
    396          interrupts must not manipulate the xStateListItem of a TCB, or any of the
    397          lists the xStateListItem can be referenced from, if the scheduler is suspended.
    398          If an interrupt needs to unblock a task while the scheduler is suspended then it
    399          moves the task's event list item into the xPendingReadyList, ready for the
    400          kernel to move the task from the pending ready list into the real ready list
    401          when the scheduler is unsuspended.  The pending ready list itself can only be
    402          accessed from a critical section. */
    403          PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
    404          
    405          #if ( configGENERATE_RUN_TIME_STATS == 1 )
    406          
    407          	/* Do not move these variables to function scope as doing so prevents the
    408          	code working with debuggers that need to remove the static qualifier. */
    409          	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter the last time a task was switched in. */
    410          	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution time as defined by the run time counter clock. */
    411          
    412          #endif
    413          
    414          /*lint -restore */
    415          
    416          /*-----------------------------------------------------------*/
    417          
    418          /* Callback function prototypes. --------------------------*/
    419          #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
    420          
    421          	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
    422          
    423          #endif
    424          
    425          #if( configUSE_TICK_HOOK > 0 )
    426          
    427          	extern void vApplicationTickHook( void ); /*lint !e526 Symbol not defined as it is an application callback. */
    428          
    429          #endif
    430          
    431          #if( configSUPPORT_STATIC_ALLOCATION == 1 )
    432          
    433          	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize ); /*lint !e526 Symbol not defined as it is an application callback. */
    434          
    435          #endif
    436          
    437          /* File private functions. --------------------------------*/
    438          
    439          /**
    440           * Utility task that simply returns pdTRUE if the task referenced by xTask is
    441           * currently in the Suspended state, or pdFALSE if the task referenced by xTask
    442           * is in any other state.
    443           */
    444          #if ( INCLUDE_vTaskSuspend == 1 )
    445          
    446          	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
    447          
    448          #endif /* INCLUDE_vTaskSuspend */
    449          
    450          /*
    451           * Utility to ready all the lists used by the scheduler.  This is called
    452           * automatically upon the creation of the first task.
    453           */
    454          static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
    455          
    456          /*
    457           * The idle task, which as all tasks is implemented as a never ending loop.
    458           * The idle task is automatically created and added to the ready lists upon
    459           * creation of the first user task.
    460           *
    461           * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
    462           * language extensions.  The equivalent prototype for this function is:
    463           *
    464           * void prvIdleTask( void *pvParameters );
    465           *
    466           */
    467          static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
    468          
    469          /*
    470           * Utility to free all memory allocated by the scheduler to hold a TCB,
    471           * including the stack pointed to by the TCB.
    472           *
    473           * This does not free memory allocated by the task itself (i.e. memory
    474           * allocated by calls to pvPortMalloc from within the tasks application code).
    475           */
    476          #if ( INCLUDE_vTaskDelete == 1 )
    477          
    478          	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
    479          
    480          #endif
    481          
    482          /*
    483           * Used only by the idle task.  This checks to see if anything has been placed
    484           * in the list of tasks waiting to be deleted.  If so the task is cleaned up
    485           * and its TCB deleted.
    486           */
    487          static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
    488          
    489          /*
    490           * The currently executing task is entering the Blocked state.  Add the task to
    491           * either the current or the overflow delayed task list.
    492           */
    493          static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely ) PRIVILEGED_FUNCTION;
    494          
    495          /*
    496           * Fills an TaskStatus_t structure with information on each task that is
    497           * referenced from the pxList list (which may be a ready list, a delayed list,
    498           * a suspended list, etc.).
    499           *
    500           * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
    501           * NORMAL APPLICATION CODE.
    502           */
    503          #if ( configUSE_TRACE_FACILITY == 1 )
    504          
    505          	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState ) PRIVILEGED_FUNCTION;
    506          
    507          #endif
    508          
    509          /*
    510           * Searches pxList for a task with name pcNameToQuery - returning a handle to
    511           * the task if it is found, or NULL if the task is not found.
    512           */
    513          #if ( INCLUDE_xTaskGetHandle == 1 )
    514          
    515          	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVILEGED_FUNCTION;
    516          
    517          #endif
    518          
    519          /*
    520           * When a task is created, the stack of the task is filled with a known value.
    521           * This function determines the 'high water mark' of the task stack by
    522           * determining how much of the stack remains at the original preset value.
    523           */
    524          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
    525          
    526          	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
    527          
    528          #endif
    529          
    530          /*
    531           * Return the amount of time, in ticks, that will pass before the kernel will
    532           * next move a task from the Blocked state to the Running state.
    533           *
    534           * This conditional compilation should use inequality to 0, not equality to 1.
    535           * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
    536           * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
    537           * set to a value other than 1.
    538           */
    539          #if ( configUSE_TICKLESS_IDLE != 0 )
    540          
    541          	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
    542          
    543          #endif
    544          
    545          /*
    546           * Set xNextTaskUnblockTime to the time at which the next Blocked state task
    547           * will exit the Blocked state.
    548           */
    549          static void prvResetNextTaskUnblockTime( void );
    550          
    551          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
    552          
    553          	/*
    554          	 * Helper function used to pad task names with spaces when printing out
    555          	 * human readable tables of task information.
    556          	 */
    557          	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
    558          
    559          #endif
    560          
    561          /*
    562           * Called after a Task_t structure has been allocated either statically or
    563           * dynamically to fill in the structure's members.
    564           */
    565          static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
    566          									const char * const pcName, 		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    567          									const uint32_t ulStackDepth,
    568          									void * const pvParameters,
    569          									UBaseType_t uxPriority,
    570          									TaskHandle_t * const pxCreatedTask,
    571          									TCB_t *pxNewTCB,
    572          									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
    573          
    574          /*
    575           * Called after a new task has been created and initialised to place the task
    576           * under the control of the scheduler.
    577           */
    578          static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
    579          
    580          /*
    581           * freertos_tasks_c_additions_init() should only be called if the user definable
    582           * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
    583           * called by the function.
    584           */
    585          #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
    586          
    587          	static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
    588          
    589          #endif
    590          
    591          /*-----------------------------------------------------------*/
    592          
    593          #if( configSUPPORT_STATIC_ALLOCATION == 1 )
    594          
    595          	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
    596          									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    597          									const uint32_t ulStackDepth,
    598          									void * const pvParameters,
    599          									UBaseType_t uxPriority,
    600          									StackType_t * const puxStackBuffer,
    601          									StaticTask_t * const pxTaskBuffer )
    602          	{
    603          	TCB_t *pxNewTCB;
    604          	TaskHandle_t xReturn;
    605          
    606          		configASSERT( puxStackBuffer != NULL );
    607          		configASSERT( pxTaskBuffer != NULL );
    608          
    609          		#if( configASSERT_DEFINED == 1 )
    610          		{
    611          			/* Sanity check that the size of the structure used to declare a
    612          			variable of type StaticTask_t equals the size of the real task
    613          			structure. */
    614          			volatile size_t xSize = sizeof( StaticTask_t );
    615          			configASSERT( xSize == sizeof( TCB_t ) );
    616          			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
    617          		}
    618          		#endif /* configASSERT_DEFINED */
    619          
    620          
    621          		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
    622          		{
    623          			/* The memory used for the task's TCB and stack are passed into this
    624          			function - use them. */
    625          			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
    626          			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
    627          
    628          			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
    629          			{
    630          				/* Tasks can be created statically or dynamically, so note this
    631          				task was created statically in case the task is later deleted. */
    632          				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
    633          			}
    634          			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    635          
    636          			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
    637          			prvAddNewTaskToReadyList( pxNewTCB );
    638          		}
    639          		else
    640          		{
    641          			xReturn = NULL;
    642          		}
    643          
    644          		return xReturn;
    645          	}
    646          
    647          #endif /* SUPPORT_STATIC_ALLOCATION */
    648          /*-----------------------------------------------------------*/
    649          
    650          #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
    651          
    652          	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask )
    653          	{
    654          	TCB_t *pxNewTCB;
    655          	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    656          
    657          		configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
    658          		configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
    659          
    660          		if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NULL ) )
    661          		{
    662          			/* Allocate space for the TCB.  Where the memory comes from depends
    663          			on the implementation of the port malloc function and whether or
    664          			not static allocation is being used. */
    665          			pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
    666          
    667          			/* Store the stack location in the TCB. */
    668          			pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
    669          
    670          			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
    671          			{
    672          				/* Tasks can be created statically or dynamically, so note this
    673          				task was created statically in case the task is later deleted. */
    674          				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
    675          			}
    676          			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    677          
    678          			prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
    679          									pxTaskDefinition->pcName,
    680          									( uint32_t ) pxTaskDefinition->usStackDepth,
    681          									pxTaskDefinition->pvParameters,
    682          									pxTaskDefinition->uxPriority,
    683          									pxCreatedTask, pxNewTCB,
    684          									pxTaskDefinition->xRegions );
    685          
    686          			prvAddNewTaskToReadyList( pxNewTCB );
    687          			xReturn = pdPASS;
    688          		}
    689          
    690          		return xReturn;
    691          	}
    692          
    693          #endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
    694          /*-----------------------------------------------------------*/
    695          
    696          #if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
    697          
    698          	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask )
    699          	{
    700          	TCB_t *pxNewTCB;
    701          	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    702          
    703          		configASSERT( pxTaskDefinition->puxStackBuffer );
    704          
    705          		if( pxTaskDefinition->puxStackBuffer != NULL )
    706          		{
    707          			/* Allocate space for the TCB.  Where the memory comes from depends
    708          			on the implementation of the port malloc function and whether or
    709          			not static allocation is being used. */
    710          			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    711          
    712          			if( pxNewTCB != NULL )
    713          			{
    714          				/* Store the stack location in the TCB. */
    715          				pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
    716          
    717          				#if( configSUPPORT_STATIC_ALLOCATION == 1 )
    718          				{
    719          					/* Tasks can be created statically or dynamically, so note
    720          					this task had a statically allocated stack in case it is
    721          					later deleted.  The TCB was allocated dynamically. */
    722          					pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
    723          				}
    724          				#endif
    725          
    726          				prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
    727          										pxTaskDefinition->pcName,
    728          										( uint32_t ) pxTaskDefinition->usStackDepth,
    729          										pxTaskDefinition->pvParameters,
    730          										pxTaskDefinition->uxPriority,
    731          										pxCreatedTask, pxNewTCB,
    732          										pxTaskDefinition->xRegions );
    733          
    734          				prvAddNewTaskToReadyList( pxNewTCB );
    735          				xReturn = pdPASS;
    736          			}
    737          		}
    738          
    739          		return xReturn;
    740          	}
    741          
    742          #endif /* portUSING_MPU_WRAPPERS */
    743          /*-----------------------------------------------------------*/
    744          
    745          #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    746          
    747          	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    748          							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    749          							const configSTACK_DEPTH_TYPE usStackDepth,
    750          							void * const pvParameters,
    751          							UBaseType_t uxPriority,
    752          							TaskHandle_t * const pxCreatedTask )
    753          	{
    754          	TCB_t *pxNewTCB;
    755          	BaseType_t xReturn;
    756          
    757          		/* If the stack grows down then allocate the stack then the TCB so the stack
    758          		does not grow into the TCB.  Likewise if the stack grows up then allocate
    759          		the TCB then the stack. */
    760          		#if( portSTACK_GROWTH > 0 )
    761          		{
    762          			/* Allocate space for the TCB.  Where the memory comes from depends on
    763          			the implementation of the port malloc function and whether or not static
    764          			allocation is being used. */
    765          			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    766          
    767          			if( pxNewTCB != NULL )
    768          			{
    769          				/* Allocate space for the stack used by the task being created.
    770          				The base of the stack memory stored in the TCB so the task can
    771          				be deleted later if required. */
    772          				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    773          
    774          				if( pxNewTCB->pxStack == NULL )
    775          				{
    776          					/* Could not allocate the stack.  Delete the allocated TCB. */
    777          					vPortFree( pxNewTCB );
    778          					pxNewTCB = NULL;
    779          				}
    780          			}
    781          		}
    782          		#else /* portSTACK_GROWTH */
    783          		{
    784          		StackType_t *pxStack;
    785          
    786          			/* Allocate space for the stack used by the task being created. */
    787          			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    788          
    789          			if( pxStack != NULL )
    790          			{
    791          				/* Allocate space for the TCB. */
    792          				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    793          
    794          				if( pxNewTCB != NULL )
    795          				{
    796          					/* Store the stack location in the TCB. */
    797          					pxNewTCB->pxStack = pxStack;
    798          				}
    799          				else
    800          				{
    801          					/* The stack cannot be used as the TCB was not created.  Free
    802          					it again. */
    803          					vPortFree( pxStack );
    804          				}
    805          			}
    806          			else
    807          			{
    808          				pxNewTCB = NULL;
    809          			}
    810          		}
    811          		#endif /* portSTACK_GROWTH */
    812          
    813          		if( pxNewTCB != NULL )
    814          		{
    815          			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consolidated for readability reasons. */
    816          			{
    817          				/* Tasks can be created statically or dynamically, so note this
    818          				task was created dynamically in case it is later deleted. */
    819          				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
    820          			}
    821          			#endif /* configSUPPORT_STATIC_ALLOCATION */
    822          
    823          			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    824          			prvAddNewTaskToReadyList( pxNewTCB );
    825          			xReturn = pdPASS;
    826          		}
    827          		else
    828          		{
    829          			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    830          		}
    831          
    832          		return xReturn;
    833          	}
    834          
    835          #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    836          /*-----------------------------------------------------------*/
    837          
    838          static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
    839          									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    840          									const uint32_t ulStackDepth,
    841          									void * const pvParameters,
    842          									UBaseType_t uxPriority,
    843          									TaskHandle_t * const pxCreatedTask,
    844          									TCB_t *pxNewTCB,
    845          									const MemoryRegion_t * const xRegions )
    846          {
    847          StackType_t *pxTopOfStack;
    848          UBaseType_t x;
    849          
    850          	#if( portUSING_MPU_WRAPPERS == 1 )
    851          		/* Should the task be created in privileged mode? */
    852          		BaseType_t xRunPrivileged;
    853          		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
    854          		{
    855          			xRunPrivileged = pdTRUE;
    856          		}
    857          		else
    858          		{
    859          			xRunPrivileged = pdFALSE;
    860          		}
    861          		uxPriority &= ~portPRIVILEGE_BIT;
    862          	#endif /* portUSING_MPU_WRAPPERS == 1 */
    863          
    864          	configASSERT( pcName );
    865          
    866          	/* Avoid dependency on memset() if it is not required. */
    867          	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
    868          	{
    869          		/* Fill the stack with a known value to assist debugging. */
    870          		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    871          	}
    872          	#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
    873          
    874          	/* Calculate the top of stack address.  This depends on whether the stack
    875          	grows from high memory to low (as per the 80x86) or vice versa.
    876          	portSTACK_GROWTH is used to make the result positive or negative as required
    877          	by the port. */
    878          	#if( portSTACK_GROWTH < 0 )
    879          	{
    880          		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    881          		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
    882          
    883          		/* Check the alignment of the calculated top of stack is correct. */
    884          		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    885          
    886          		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
    887          		{
    888          			/* Also record the stack's high address, which may assist
    889          			debugging. */
    890          			pxNewTCB->pxEndOfStack = pxTopOfStack;
    891          		}
    892          		#endif /* configRECORD_STACK_HIGH_ADDRESS */
    893          	}
    894          	#else /* portSTACK_GROWTH */
    895          	{
    896          		pxTopOfStack = pxNewTCB->pxStack;
    897          
    898          		/* Check the alignment of the stack buffer is correct. */
    899          		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    900          
    901          		/* The other extreme of the stack space is required if stack checking is
    902          		performed. */
    903          		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    904          	}
    905          	#endif /* portSTACK_GROWTH */
    906          
    907          	/* Store the task name in the TCB. */
    908          	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    909          	{
    910          		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    911          
    912          		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
    913          		configMAX_TASK_NAME_LEN characters just in case the memory after the
    914          		string is not accessible (extremely unlikely). */
    915          		if( pcName[ x ] == ( char ) 0x00 )
    916          		{
    917          			break;
    918          		}
    919          		else
    920          		{
    921          			mtCOVERAGE_TEST_MARKER();
    922          		}
    923          	}
    924          
    925          	/* Ensure the name string is terminated in the case that the string length
    926          	was greater or equal to configMAX_TASK_NAME_LEN. */
    927          	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    928          
    929          	/* This is used as an array index so must ensure it's not too large.  First
    930          	remove the privilege bit if one is present. */
    931          	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    932          	{
    933          		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    934          	}
    935          	else
    936          	{
    937          		mtCOVERAGE_TEST_MARKER();
    938          	}
    939          
    940          	pxNewTCB->uxPriority = uxPriority;
    941          	#if ( configUSE_MUTEXES == 1 )
    942          	{
    943          		pxNewTCB->uxBasePriority = uxPriority;
    944          		pxNewTCB->uxMutexesHeld = 0;
    945          	}
    946          	#endif /* configUSE_MUTEXES */
    947          
    948          	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    949          	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    950          
    951          	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
    952          	back to	the containing TCB from a generic item in a list. */
    953          	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    954          
    955          	/* Event lists are always in priority order. */
    956          	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    957          	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    958          
    959          	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
    960          	{
    961          		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
    962          	}
    963          	#endif /* portCRITICAL_NESTING_IN_TCB */
    964          
    965          	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
    966          	{
    967          		pxNewTCB->pxTaskTag = NULL;
    968          	}
    969          	#endif /* configUSE_APPLICATION_TASK_TAG */
    970          
    971          	#if ( configGENERATE_RUN_TIME_STATS == 1 )
    972          	{
    973          		pxNewTCB->ulRunTimeCounter = 0UL;
    974          	}
    975          	#endif /* configGENERATE_RUN_TIME_STATS */
    976          
    977          	#if ( portUSING_MPU_WRAPPERS == 1 )
    978          	{
    979          		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
    980          	}
    981          	#else
    982          	{
    983          		/* Avoid compiler warning about unreferenced parameter. */
    984          		( void ) xRegions;
    985          	}
    986          	#endif
    987          
    988          	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
    989          	{
    990          		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
    991          		{
    992          			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
    993          		}
    994          	}
    995          	#endif
    996          
    997          	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
    998          	{
    999          		pxNewTCB->ulNotifiedValue = 0;
   1000          		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   1001          	}
   1002          	#endif
   1003          
   1004          	#if ( configUSE_NEWLIB_REENTRANT == 1 )
   1005          	{
   1006          		/* Initialise this task's Newlib reent structure. */
   1007          		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
   1008          	}
   1009          	#endif
   1010          
   1011          	#if( INCLUDE_xTaskAbortDelay == 1 )
   1012          	{
   1013          		pxNewTCB->ucDelayAborted = pdFALSE;
   1014          	}
   1015          	#endif
   1016          
   1017          	/* Initialize the TCB stack to look as if the task was already running,
   1018          	but had been interrupted by the scheduler.  The return address is set
   1019          	to the start of the task function. Once the stack has been initialised
   1020          	the top of stack variable is updated. */
   1021          	#if( portUSING_MPU_WRAPPERS == 1 )
   1022          	{
   1023          		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
   1024          	}
   1025          	#else /* portUSING_MPU_WRAPPERS */
   1026          	{
   1027          		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   1028          	}
   1029          	#endif /* portUSING_MPU_WRAPPERS */
   1030          
   1031          	if( pxCreatedTask != NULL )
   1032          	{
   1033          		/* Pass the handle out in an anonymous way.  The handle can be used to
   1034          		change the created task's priority, delete the created task, etc.*/
   1035          		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
   1036          	}
   1037          	else
   1038          	{
   1039          		mtCOVERAGE_TEST_MARKER();
   1040          	}
   1041          }
   1042          /*-----------------------------------------------------------*/
   1043          
   1044          static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
   1045          {
   1046          	/* Ensure interrupts don't access the task lists while the lists are being
   1047          	updated. */
   1048          	taskENTER_CRITICAL();
   1049          	{
   1050          		uxCurrentNumberOfTasks++;
   1051          		if( pxCurrentTCB == NULL )
   1052          		{
   1053          			/* There are no other tasks, or all the other tasks are in
   1054          			the suspended state - make this the current task. */
   1055          			pxCurrentTCB = pxNewTCB;
   1056          
   1057          			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
   1058          			{
   1059          				/* This is the first task to be created so do the preliminary
   1060          				initialisation required.  We will not recover if this call
   1061          				fails, but we will report the failure. */
   1062          				prvInitialiseTaskLists();
   1063          			}
   1064          			else
   1065          			{
   1066          				mtCOVERAGE_TEST_MARKER();
   1067          			}
   1068          		}
   1069          		else
   1070          		{
   1071          			/* If the scheduler is not already running, make this task the
   1072          			current task if it is the highest priority task to be created
   1073          			so far. */
   1074          			if( xSchedulerRunning == pdFALSE )
   1075          			{
   1076          				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
   1077          				{
   1078          					pxCurrentTCB = pxNewTCB;
   1079          				}
   1080          				else
   1081          				{
   1082          					mtCOVERAGE_TEST_MARKER();
   1083          				}
   1084          			}
   1085          			else
   1086          			{
   1087          				mtCOVERAGE_TEST_MARKER();
   1088          			}
   1089          		}
   1090          
   1091          		uxTaskNumber++;
   1092          
   1093          		#if ( configUSE_TRACE_FACILITY == 1 )
   1094          		{
   1095          			/* Add a counter into the TCB for tracing only. */
   1096          			pxNewTCB->uxTCBNumber = uxTaskNumber;
   1097          		}
   1098          		#endif /* configUSE_TRACE_FACILITY */
   1099          		traceTASK_CREATE( pxNewTCB );
   1100          
   1101          		prvAddTaskToReadyList( pxNewTCB );
   1102          
   1103          		portSETUP_TCB( pxNewTCB );
   1104          	}
   1105          	taskEXIT_CRITICAL();
   1106          
   1107          	if( xSchedulerRunning != pdFALSE )
   1108          	{
   1109          		/* If the created task is of a higher priority than the current task
   1110          		then it should run now. */
   1111          		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
   1112          		{
   1113          			taskYIELD_IF_USING_PREEMPTION();
   1114          		}
   1115          		else
   1116          		{
   1117          			mtCOVERAGE_TEST_MARKER();
   1118          		}
   1119          	}
   1120          	else
   1121          	{
   1122          		mtCOVERAGE_TEST_MARKER();
   1123          	}
   1124          }
   1125          /*-----------------------------------------------------------*/
   1126          
   1127          #if ( INCLUDE_vTaskDelete == 1 )
   1128          
   1129          	void vTaskDelete( TaskHandle_t xTaskToDelete )
   1130          	{
   1131          	TCB_t *pxTCB;
   1132          
   1133          		taskENTER_CRITICAL();
   1134          		{
   1135          			/* If null is passed in here then it is the calling task that is
   1136          			being deleted. */
   1137          			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
   1138          
   1139          			/* Remove task from the ready list. */
   1140          			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   1141          			{
   1142          				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   1143          			}
   1144          			else
   1145          			{
   1146          				mtCOVERAGE_TEST_MARKER();
   1147          			}
   1148          
   1149          			/* Is the task waiting on an event also? */
   1150          			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   1151          			{
   1152          				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   1153          			}
   1154          			else
   1155          			{
   1156          				mtCOVERAGE_TEST_MARKER();
   1157          			}
   1158          
   1159          			/* Increment the uxTaskNumber also so kernel aware debuggers can
   1160          			detect that the task lists need re-generating.  This is done before
   1161          			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
   1162          			not return. */
   1163          			uxTaskNumber++;
   1164          
   1165          			if( pxTCB == pxCurrentTCB )
   1166          			{
   1167          				/* A task is deleting itself.  This cannot complete within the
   1168          				task itself, as a context switch to another task is required.
   1169          				Place the task in the termination list.  The idle task will
   1170          				check the termination list and free up any memory allocated by
   1171          				the scheduler for the TCB and stack of the deleted task. */
   1172          				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
   1173          
   1174          				/* Increment the ucTasksDeleted variable so the idle task knows
   1175          				there is a task that has been deleted and that it should therefore
   1176          				check the xTasksWaitingTermination list. */
   1177          				++uxDeletedTasksWaitingCleanUp;
   1178          
   1179          				/* The pre-delete hook is primarily for the Windows simulator,
   1180          				in which Windows specific clean up operations are performed,
   1181          				after which it is not possible to yield away from this task -
   1182          				hence xYieldPending is used to latch that a context switch is
   1183          				required. */
   1184          				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
   1185          			}
   1186          			else
   1187          			{
   1188          				--uxCurrentNumberOfTasks;
   1189          				prvDeleteTCB( pxTCB );
   1190          
   1191          				/* Reset the next expected unblock time in case it referred to
   1192          				the task that has just been deleted. */
   1193          				prvResetNextTaskUnblockTime();
   1194          			}
   1195          
   1196          			traceTASK_DELETE( pxTCB );
   1197          		}
   1198          		taskEXIT_CRITICAL();
   1199          
   1200          		/* Force a reschedule if it is the currently running task that has just
   1201          		been deleted. */
   1202          		if( xSchedulerRunning != pdFALSE )
   1203          		{
   1204          			if( pxTCB == pxCurrentTCB )
   1205          			{
   1206          				configASSERT( uxSchedulerSuspended == 0 );
   1207          				portYIELD_WITHIN_API();
   1208          			}
   1209          			else
   1210          			{
   1211          				mtCOVERAGE_TEST_MARKER();
   1212          			}
   1213          		}
   1214          	}
   1215          
   1216          #endif /* INCLUDE_vTaskDelete */
   1217          /*-----------------------------------------------------------*/
   1218          
   1219          #if ( INCLUDE_vTaskDelayUntil == 1 )
   1220          
   1221          	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
   1222          	{
   1223          	TickType_t xTimeToWake;
   1224          	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
   1225          
   1226          		configASSERT( pxPreviousWakeTime );
   1227          		configASSERT( ( xTimeIncrement > 0U ) );
   1228          		configASSERT( uxSchedulerSuspended == 0 );
   1229          
   1230          		vTaskSuspendAll();
   1231          		{
   1232          			/* Minor optimisation.  The tick count cannot change in this
   1233          			block. */
   1234          			const TickType_t xConstTickCount = xTickCount;
   1235          
   1236          			/* Generate the tick time at which the task wants to wake. */
   1237          			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
   1238          
   1239          			if( xConstTickCount < *pxPreviousWakeTime )
   1240          			{
   1241          				/* The tick count has overflowed since this function was
   1242          				lasted called.  In this case the only time we should ever
   1243          				actually delay is if the wake time has also	overflowed,
   1244          				and the wake time is greater than the tick time.  When this
   1245          				is the case it is as if neither time had overflowed. */
   1246          				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
   1247          				{
   1248          					xShouldDelay = pdTRUE;
   1249          				}
   1250          				else
   1251          				{
   1252          					mtCOVERAGE_TEST_MARKER();
   1253          				}
   1254          			}
   1255          			else
   1256          			{
   1257          				/* The tick time has not overflowed.  In this case we will
   1258          				delay if either the wake time has overflowed, and/or the
   1259          				tick time is less than the wake time. */
   1260          				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
   1261          				{
   1262          					xShouldDelay = pdTRUE;
   1263          				}
   1264          				else
   1265          				{
   1266          					mtCOVERAGE_TEST_MARKER();
   1267          				}
   1268          			}
   1269          
   1270          			/* Update the wake time ready for the next call. */
   1271          			*pxPreviousWakeTime = xTimeToWake;
   1272          
   1273          			if( xShouldDelay != pdFALSE )
   1274          			{
   1275          				traceTASK_DELAY_UNTIL( xTimeToWake );
   1276          
   1277          				/* prvAddCurrentTaskToDelayedList() needs the block time, not
   1278          				the time to wake, so subtract the current tick count. */
   1279          				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
   1280          			}
   1281          			else
   1282          			{
   1283          				mtCOVERAGE_TEST_MARKER();
   1284          			}
   1285          		}
   1286          		xAlreadyYielded = xTaskResumeAll();
   1287          
   1288          		/* Force a reschedule if xTaskResumeAll has not already done so, we may
   1289          		have put ourselves to sleep. */
   1290          		if( xAlreadyYielded == pdFALSE )
   1291          		{
   1292          			portYIELD_WITHIN_API();
   1293          		}
   1294          		else
   1295          		{
   1296          			mtCOVERAGE_TEST_MARKER();
   1297          		}
   1298          	}
   1299          
   1300          #endif /* INCLUDE_vTaskDelayUntil */
   1301          /*-----------------------------------------------------------*/
   1302          
   1303          #if ( INCLUDE_vTaskDelay == 1 )
   1304          
   1305          	void vTaskDelay( const TickType_t xTicksToDelay )
   1306          	{
   1307          	BaseType_t xAlreadyYielded = pdFALSE;
   1308          
   1309          		/* A delay time of zero just forces a reschedule. */
   1310          		if( xTicksToDelay > ( TickType_t ) 0U )
   1311          		{
   1312          			configASSERT( uxSchedulerSuspended == 0 );
   1313          			vTaskSuspendAll();
   1314          			{
   1315          				traceTASK_DELAY();
   1316          
   1317          				/* A task that is removed from the event list while the
   1318          				scheduler is suspended will not get placed in the ready
   1319          				list or removed from the blocked list until the scheduler
   1320          				is resumed.
   1321          
   1322          				This task cannot be in an event list as it is the currently
   1323          				executing task. */
   1324          				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
   1325          			}
   1326          			xAlreadyYielded = xTaskResumeAll();
   1327          		}
   1328          		else
   1329          		{
   1330          			mtCOVERAGE_TEST_MARKER();
   1331          		}
   1332          
   1333          		/* Force a reschedule if xTaskResumeAll has not already done so, we may
   1334          		have put ourselves to sleep. */
   1335          		if( xAlreadyYielded == pdFALSE )
   1336          		{
   1337          			portYIELD_WITHIN_API();
   1338          		}
   1339          		else
   1340          		{
   1341          			mtCOVERAGE_TEST_MARKER();
   1342          		}
   1343          	}
   1344          
   1345          #endif /* INCLUDE_vTaskDelay */
   1346          /*-----------------------------------------------------------*/
   1347          
   1348          #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )
   1349          
   1350          	eTaskState eTaskGetState( TaskHandle_t xTask )
   1351          	{
   1352          	eTaskState eReturn;
   1353          	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
   1354          	const TCB_t * const pxTCB = xTask;
   1355          
   1356          		configASSERT( pxTCB );
   1357          
   1358          		if( pxTCB == pxCurrentTCB )
   1359          		{
   1360          			/* The task calling this function is querying its own state. */
   1361          			eReturn = eRunning;
   1362          		}
   1363          		else
   1364          		{
   1365          			taskENTER_CRITICAL();
   1366          			{
   1367          				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
   1368          				pxDelayedList = pxDelayedTaskList;
   1369          				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
   1370          			}
   1371          			taskEXIT_CRITICAL();
   1372          
   1373          			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
   1374          			{
   1375          				/* The task being queried is referenced from one of the Blocked
   1376          				lists. */
   1377          				eReturn = eBlocked;
   1378          			}
   1379          
   1380          			#if ( INCLUDE_vTaskSuspend == 1 )
   1381          				else if( pxStateList == &xSuspendedTaskList )
   1382          				{
   1383          					/* The task being queried is referenced from the suspended
   1384          					list.  Is it genuinely suspended or is it blocked
   1385          					indefinitely? */
   1386          					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
   1387          					{
   1388          						#if( configUSE_TASK_NOTIFICATIONS == 1 )
   1389          						{
   1390          							/* The task does not appear on the event list item of
   1391          							and of the RTOS objects, but could still be in the
   1392          							blocked state if it is waiting on its notification
   1393          							rather than waiting on an object. */
   1394          							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
   1395          							{
   1396          								eReturn = eBlocked;
   1397          							}
   1398          							else
   1399          							{
   1400          								eReturn = eSuspended;
   1401          							}
   1402          						}
   1403          						#else
   1404          						{
   1405          							eReturn = eSuspended;
   1406          						}
   1407          						#endif
   1408          					}
   1409          					else
   1410          					{
   1411          						eReturn = eBlocked;
   1412          					}
   1413          				}
   1414          			#endif
   1415          
   1416          			#if ( INCLUDE_vTaskDelete == 1 )
   1417          				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
   1418          				{
   1419          					/* The task being queried is referenced from the deleted
   1420          					tasks list, or it is not referenced from any lists at
   1421          					all. */
   1422          					eReturn = eDeleted;
   1423          				}
   1424          			#endif
   1425          
   1426          			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
   1427          			{
   1428          				/* If the task is not in any other state, it must be in the
   1429          				Ready (including pending ready) state. */
   1430          				eReturn = eReady;
   1431          			}
   1432          		}
   1433          
   1434          		return eReturn;
   1435          	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   1436          
   1437          #endif /* INCLUDE_eTaskGetState */
   1438          /*-----------------------------------------------------------*/
   1439          
   1440          #if ( INCLUDE_uxTaskPriorityGet == 1 )
   1441          
   1442          	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
   1443          	{
   1444          	TCB_t const *pxTCB;
   1445          	UBaseType_t uxReturn;
   1446          
   1447          		taskENTER_CRITICAL();
   1448          		{
   1449          			/* If null is passed in here then it is the priority of the task
   1450          			that called uxTaskPriorityGet() that is being queried. */
   1451          			pxTCB = prvGetTCBFromHandle( xTask );
   1452          			uxReturn = pxTCB->uxPriority;
   1453          		}
   1454          		taskEXIT_CRITICAL();
   1455          
   1456          		return uxReturn;
   1457          	}
   1458          
   1459          #endif /* INCLUDE_uxTaskPriorityGet */
   1460          /*-----------------------------------------------------------*/
   1461          
   1462          #if ( INCLUDE_uxTaskPriorityGet == 1 )
   1463          
   1464          	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
   1465          	{
   1466          	TCB_t const *pxTCB;
   1467          	UBaseType_t uxReturn, uxSavedInterruptState;
   1468          
   1469          		/* RTOS ports that support interrupt nesting have the concept of a
   1470          		maximum	system call (or maximum API call) interrupt priority.
   1471          		Interrupts that are	above the maximum system call priority are keep
   1472          		permanently enabled, even when the RTOS kernel is in a critical section,
   1473          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   1474          		is defined in FreeRTOSConfig.h then
   1475          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1476          		failure if a FreeRTOS API function is called from an interrupt that has
   1477          		been assigned a priority above the configured maximum system call
   1478          		priority.  Only FreeRTOS functions that end in FromISR can be called
   1479          		from interrupts	that have been assigned a priority at or (logically)
   1480          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   1481          		separate interrupt safe API to ensure interrupt entry is as fast and as
   1482          		simple as possible.  More information (albeit Cortex-M specific) is
   1483          		provided on the following link:
   1484          		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1485          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1486          
   1487          		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
   1488          		{
   1489          			/* If null is passed in here then it is the priority of the calling
   1490          			task that is being queried. */
   1491          			pxTCB = prvGetTCBFromHandle( xTask );
   1492          			uxReturn = pxTCB->uxPriority;
   1493          		}
   1494          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
   1495          
   1496          		return uxReturn;
   1497          	}
   1498          
   1499          #endif /* INCLUDE_uxTaskPriorityGet */
   1500          /*-----------------------------------------------------------*/
   1501          
   1502          #if ( INCLUDE_vTaskPrioritySet == 1 )
   1503          
   1504          	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
   1505          	{
   1506          	TCB_t *pxTCB;
   1507          	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
   1508          	BaseType_t xYieldRequired = pdFALSE;
   1509          
   1510          		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
   1511          
   1512          		/* Ensure the new priority is valid. */
   1513          		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   1514          		{
   1515          			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   1516          		}
   1517          		else
   1518          		{
   1519          			mtCOVERAGE_TEST_MARKER();
   1520          		}
   1521          
   1522          		taskENTER_CRITICAL();
   1523          		{
   1524          			/* If null is passed in here then it is the priority of the calling
   1525          			task that is being changed. */
   1526          			pxTCB = prvGetTCBFromHandle( xTask );
   1527          
   1528          			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
   1529          
   1530          			#if ( configUSE_MUTEXES == 1 )
   1531          			{
   1532          				uxCurrentBasePriority = pxTCB->uxBasePriority;
   1533          			}
   1534          			#else
   1535          			{
   1536          				uxCurrentBasePriority = pxTCB->uxPriority;
   1537          			}
   1538          			#endif
   1539          
   1540          			if( uxCurrentBasePriority != uxNewPriority )
   1541          			{
   1542          				/* The priority change may have readied a task of higher
   1543          				priority than the calling task. */
   1544          				if( uxNewPriority > uxCurrentBasePriority )
   1545          				{
   1546          					if( pxTCB != pxCurrentTCB )
   1547          					{
   1548          						/* The priority of a task other than the currently
   1549          						running task is being raised.  Is the priority being
   1550          						raised above that of the running task? */
   1551          						if( uxNewPriority >= pxCurrentTCB->uxPriority )
   1552          						{
   1553          							xYieldRequired = pdTRUE;
   1554          						}
   1555          						else
   1556          						{
   1557          							mtCOVERAGE_TEST_MARKER();
   1558          						}
   1559          					}
   1560          					else
   1561          					{
   1562          						/* The priority of the running task is being raised,
   1563          						but the running task must already be the highest
   1564          						priority task able to run so no yield is required. */
   1565          					}
   1566          				}
   1567          				else if( pxTCB == pxCurrentTCB )
   1568          				{
   1569          					/* Setting the priority of the running task down means
   1570          					there may now be another task of higher priority that
   1571          					is ready to execute. */
   1572          					xYieldRequired = pdTRUE;
   1573          				}
   1574          				else
   1575          				{
   1576          					/* Setting the priority of any other task down does not
   1577          					require a yield as the running task must be above the
   1578          					new priority of the task being modified. */
   1579          				}
   1580          
   1581          				/* Remember the ready list the task might be referenced from
   1582          				before its uxPriority member is changed so the
   1583          				taskRESET_READY_PRIORITY() macro can function correctly. */
   1584          				uxPriorityUsedOnEntry = pxTCB->uxPriority;
   1585          
   1586          				#if ( configUSE_MUTEXES == 1 )
   1587          				{
   1588          					/* Only change the priority being used if the task is not
   1589          					currently using an inherited priority. */
   1590          					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
   1591          					{
   1592          						pxTCB->uxPriority = uxNewPriority;
   1593          					}
   1594          					else
   1595          					{
   1596          						mtCOVERAGE_TEST_MARKER();
   1597          					}
   1598          
   1599          					/* The base priority gets set whatever. */
   1600          					pxTCB->uxBasePriority = uxNewPriority;
   1601          				}
   1602          				#else
   1603          				{
   1604          					pxTCB->uxPriority = uxNewPriority;
   1605          				}
   1606          				#endif
   1607          
   1608          				/* Only reset the event list item value if the value is not
   1609          				being used for anything else. */
   1610          				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   1611          				{
   1612          					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1613          				}
   1614          				else
   1615          				{
   1616          					mtCOVERAGE_TEST_MARKER();
   1617          				}
   1618          
   1619          				/* If the task is in the blocked or suspended list we need do
   1620          				nothing more than change its priority variable. However, if
   1621          				the task is in a ready list it needs to be removed and placed
   1622          				in the list appropriate to its new priority. */
   1623          				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
   1624          				{
   1625          					/* The task is currently in its ready list - remove before
   1626          					adding it to it's new ready list.  As we are in a critical
   1627          					section we can do this even if the scheduler is suspended. */
   1628          					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   1629          					{
   1630          						/* It is known that the task is in its ready list so
   1631          						there is no need to check again and the port level
   1632          						reset macro can be called directly. */
   1633          						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
   1634          					}
   1635          					else
   1636          					{
   1637          						mtCOVERAGE_TEST_MARKER();
   1638          					}
   1639          					prvAddTaskToReadyList( pxTCB );
   1640          				}
   1641          				else
   1642          				{
   1643          					mtCOVERAGE_TEST_MARKER();
   1644          				}
   1645          
   1646          				if( xYieldRequired != pdFALSE )
   1647          				{
   1648          					taskYIELD_IF_USING_PREEMPTION();
   1649          				}
   1650          				else
   1651          				{
   1652          					mtCOVERAGE_TEST_MARKER();
   1653          				}
   1654          
   1655          				/* Remove compiler warning about unused variables when the port
   1656          				optimised task selection is not being used. */
   1657          				( void ) uxPriorityUsedOnEntry;
   1658          			}
   1659          		}
   1660          		taskEXIT_CRITICAL();
   1661          	}
   1662          
   1663          #endif /* INCLUDE_vTaskPrioritySet */
   1664          /*-----------------------------------------------------------*/
   1665          
   1666          #if ( INCLUDE_vTaskSuspend == 1 )
   1667          
   1668          	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
   1669          	{
   1670          	TCB_t *pxTCB;
   1671          
   1672          		taskENTER_CRITICAL();
   1673          		{
   1674          			/* If null is passed in here then it is the running task that is
   1675          			being suspended. */
   1676          			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
   1677          
   1678          			traceTASK_SUSPEND( pxTCB );
   1679          
   1680          			/* Remove task from the ready/delayed list and place in the
   1681          			suspended list. */
   1682          			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   1683          			{
   1684          				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   1685          			}
   1686          			else
   1687          			{
   1688          				mtCOVERAGE_TEST_MARKER();
   1689          			}
   1690          
   1691          			/* Is the task waiting on an event also? */
   1692          			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   1693          			{
   1694          				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   1695          			}
   1696          			else
   1697          			{
   1698          				mtCOVERAGE_TEST_MARKER();
   1699          			}
   1700          
   1701          			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
   1702          
   1703          			#if( configUSE_TASK_NOTIFICATIONS == 1 )
   1704          			{
   1705          				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
   1706          				{
   1707          					/* The task was blocked to wait for a notification, but is
   1708          					now suspended, so no notification was received. */
   1709          					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   1710          				}
   1711          			}
   1712          			#endif
   1713          		}
   1714          		taskEXIT_CRITICAL();
   1715          
   1716          		if( xSchedulerRunning != pdFALSE )
   1717          		{
   1718          			/* Reset the next expected unblock time in case it referred to the
   1719          			task that is now in the Suspended state. */
   1720          			taskENTER_CRITICAL();
   1721          			{
   1722          				prvResetNextTaskUnblockTime();
   1723          			}
   1724          			taskEXIT_CRITICAL();
   1725          		}
   1726          		else
   1727          		{
   1728          			mtCOVERAGE_TEST_MARKER();
   1729          		}
   1730          
   1731          		if( pxTCB == pxCurrentTCB )
   1732          		{
   1733          			if( xSchedulerRunning != pdFALSE )
   1734          			{
   1735          				/* The current task has just been suspended. */
   1736          				configASSERT( uxSchedulerSuspended == 0 );
   1737          				portYIELD_WITHIN_API();
   1738          			}
   1739          			else
   1740          			{
   1741          				/* The scheduler is not running, but the task that was pointed
   1742          				to by pxCurrentTCB has just been suspended and pxCurrentTCB
   1743          				must be adjusted to point to a different task. */
   1744          				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
   1745          				{
   1746          					/* No other tasks are ready, so set pxCurrentTCB back to
   1747          					NULL so when the next task is created pxCurrentTCB will
   1748          					be set to point to it no matter what its relative priority
   1749          					is. */
   1750          					pxCurrentTCB = NULL;
   1751          				}
   1752          				else
   1753          				{
   1754          					vTaskSwitchContext();
   1755          				}
   1756          			}
   1757          		}
   1758          		else
   1759          		{
   1760          			mtCOVERAGE_TEST_MARKER();
   1761          		}
   1762          	}
   1763          
   1764          #endif /* INCLUDE_vTaskSuspend */
   1765          /*-----------------------------------------------------------*/
   1766          
   1767          #if ( INCLUDE_vTaskSuspend == 1 )
   1768          
   1769          	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
   1770          	{
   1771          	BaseType_t xReturn = pdFALSE;
   1772          	const TCB_t * const pxTCB = xTask;
   1773          
   1774          		/* Accesses xPendingReadyList so must be called from a critical
   1775          		section. */
   1776          
   1777          		/* It does not make sense to check if the calling task is suspended. */
   1778          		configASSERT( xTask );
   1779          
   1780          		/* Is the task being resumed actually in the suspended list? */
   1781          		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
   1782          		{
   1783          			/* Has the task already been resumed from within an ISR? */
   1784          			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
   1785          			{
   1786          				/* Is it in the suspended list because it is in the	Suspended
   1787          				state, or because is is blocked with no timeout? */
   1788          				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
   1789          				{
   1790          					xReturn = pdTRUE;
   1791          				}
   1792          				else
   1793          				{
   1794          					mtCOVERAGE_TEST_MARKER();
   1795          				}
   1796          			}
   1797          			else
   1798          			{
   1799          				mtCOVERAGE_TEST_MARKER();
   1800          			}
   1801          		}
   1802          		else
   1803          		{
   1804          			mtCOVERAGE_TEST_MARKER();
   1805          		}
   1806          
   1807          		return xReturn;
   1808          	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   1809          
   1810          #endif /* INCLUDE_vTaskSuspend */
   1811          /*-----------------------------------------------------------*/
   1812          
   1813          #if ( INCLUDE_vTaskSuspend == 1 )
   1814          
   1815          	void vTaskResume( TaskHandle_t xTaskToResume )
   1816          	{
   1817          	TCB_t * const pxTCB = xTaskToResume;
   1818          
   1819          		/* It does not make sense to resume the calling task. */
   1820          		configASSERT( xTaskToResume );
   1821          
   1822          		/* The parameter cannot be NULL as it is impossible to resume the
   1823          		currently executing task. */
   1824          		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
   1825          		{
   1826          			taskENTER_CRITICAL();
   1827          			{
   1828          				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
   1829          				{
   1830          					traceTASK_RESUME( pxTCB );
   1831          
   1832          					/* The ready list can be accessed even if the scheduler is
   1833          					suspended because this is inside a critical section. */
   1834          					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
   1835          					prvAddTaskToReadyList( pxTCB );
   1836          
   1837          					/* A higher priority task may have just been resumed. */
   1838          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1839          					{
   1840          						/* This yield may not cause the task just resumed to run,
   1841          						but will leave the lists in the correct state for the
   1842          						next yield. */
   1843          						taskYIELD_IF_USING_PREEMPTION();
   1844          					}
   1845          					else
   1846          					{
   1847          						mtCOVERAGE_TEST_MARKER();
   1848          					}
   1849          				}
   1850          				else
   1851          				{
   1852          					mtCOVERAGE_TEST_MARKER();
   1853          				}
   1854          			}
   1855          			taskEXIT_CRITICAL();
   1856          		}
   1857          		else
   1858          		{
   1859          			mtCOVERAGE_TEST_MARKER();
   1860          		}
   1861          	}
   1862          
   1863          #endif /* INCLUDE_vTaskSuspend */
   1864          
   1865          /*-----------------------------------------------------------*/
   1866          
   1867          #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
   1868          
   1869          	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
   1870          	{
   1871          	BaseType_t xYieldRequired = pdFALSE;
   1872          	TCB_t * const pxTCB = xTaskToResume;
   1873          	UBaseType_t uxSavedInterruptStatus;
   1874          
   1875          		configASSERT( xTaskToResume );
   1876          
   1877          		/* RTOS ports that support interrupt nesting have the concept of a
   1878          		maximum	system call (or maximum API call) interrupt priority.
   1879          		Interrupts that are	above the maximum system call priority are keep
   1880          		permanently enabled, even when the RTOS kernel is in a critical section,
   1881          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   1882          		is defined in FreeRTOSConfig.h then
   1883          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1884          		failure if a FreeRTOS API function is called from an interrupt that has
   1885          		been assigned a priority above the configured maximum system call
   1886          		priority.  Only FreeRTOS functions that end in FromISR can be called
   1887          		from interrupts	that have been assigned a priority at or (logically)
   1888          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   1889          		separate interrupt safe API to ensure interrupt entry is as fast and as
   1890          		simple as possible.  More information (albeit Cortex-M specific) is
   1891          		provided on the following link:
   1892          		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1893          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1894          
   1895          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   1896          		{
   1897          			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
   1898          			{
   1899          				traceTASK_RESUME_FROM_ISR( pxTCB );
   1900          
   1901          				/* Check the ready lists can be accessed. */
   1902          				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   1903          				{
   1904          					/* Ready lists can be accessed so move the task from the
   1905          					suspended list to the ready list directly. */
   1906          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1907          					{
   1908          						xYieldRequired = pdTRUE;
   1909          					}
   1910          					else
   1911          					{
   1912          						mtCOVERAGE_TEST_MARKER();
   1913          					}
   1914          
   1915          					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   1916          					prvAddTaskToReadyList( pxTCB );
   1917          				}
   1918          				else
   1919          				{
   1920          					/* The delayed or ready lists cannot be accessed so the task
   1921          					is held in the pending ready list until the scheduler is
   1922          					unsuspended. */
   1923          					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   1924          				}
   1925          			}
   1926          			else
   1927          			{
   1928          				mtCOVERAGE_TEST_MARKER();
   1929          			}
   1930          		}
   1931          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   1932          
   1933          		return xYieldRequired;
   1934          	}
   1935          
   1936          #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
   1937          /*-----------------------------------------------------------*/
   1938          
   1939          void vTaskStartScheduler( void )
   1940          {
   1941          BaseType_t xReturn;
   1942          
   1943          	/* Add the idle task at the lowest priority. */
   1944          	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
   1945          	{
   1946          		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
   1947          		StackType_t *pxIdleTaskStackBuffer = NULL;
   1948          		uint32_t ulIdleTaskStackSize;
   1949          
   1950          		/* The Idle task is created using user provided RAM - obtain the
   1951          		address of the RAM then create the idle task. */
   1952          		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
   1953          		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
   1954          												configIDLE_TASK_NAME,
   1955          												ulIdleTaskStackSize,
   1956          												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
   1957          												portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
   1958          												pxIdleTaskStackBuffer,
   1959          												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
   1960          
   1961          		if( xIdleTaskHandle != NULL )
   1962          		{
   1963          			xReturn = pdPASS;
   1964          		}
   1965          		else
   1966          		{
   1967          			xReturn = pdFAIL;
   1968          		}
   1969          	}
   1970          	#else
   1971          	{
   1972          		/* The Idle task is being created using dynamically allocated RAM. */
   1973          		xReturn = xTaskCreate(	prvIdleTask,
   1974          								configIDLE_TASK_NAME,
   1975          								configMINIMAL_STACK_SIZE,
   1976          								( void * ) NULL,
   1977          								portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
   1978          								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
   1979          	}
   1980          	#endif /* configSUPPORT_STATIC_ALLOCATION */
   1981          
   1982          	#if ( configUSE_TIMERS == 1 )
   1983          	{
   1984          		if( xReturn == pdPASS )
   1985          		{
   1986          			xReturn = xTimerCreateTimerTask();
   1987          		}
   1988          		else
   1989          		{
   1990          			mtCOVERAGE_TEST_MARKER();
   1991          		}
   1992          	}
   1993          	#endif /* configUSE_TIMERS */
   1994          
   1995          	if( xReturn == pdPASS )
   1996          	{
   1997          		/* freertos_tasks_c_additions_init() should only be called if the user
   1998          		definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
   1999          		the only macro called by the function. */
   2000          		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
   2001          		{
   2002          			freertos_tasks_c_additions_init();
   2003          		}
   2004          		#endif
   2005          
   2006          		/* Interrupts are turned off here, to ensure a tick does not occur
   2007          		before or during the call to xPortStartScheduler().  The stacks of
   2008          		the created tasks contain a status word with interrupts switched on
   2009          		so interrupts will automatically get re-enabled when the first task
   2010          		starts to run. */
   2011          		portDISABLE_INTERRUPTS();
   2012          
   2013          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   2014          		{
   2015          			/* Switch Newlib's _impure_ptr variable to point to the _reent
   2016          			structure specific to the task that will run first. */
   2017          			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
   2018          		}
   2019          		#endif /* configUSE_NEWLIB_REENTRANT */
   2020          
   2021          		xNextTaskUnblockTime = portMAX_DELAY;
   2022          		xSchedulerRunning = pdTRUE;
   2023          		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
   2024          
   2025          		/* If configGENERATE_RUN_TIME_STATS is defined then the following
   2026          		macro must be defined to configure the timer/counter used to generate
   2027          		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
   2028          		is set to 0 and the following line fails to build then ensure you do not
   2029          		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
   2030          		FreeRTOSConfig.h file. */
   2031          		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
   2032          
   2033          		traceTASK_SWITCHED_IN();
   2034          
   2035          		/* Setting up the timer tick is hardware specific and thus in the
   2036          		portable interface. */
   2037          		if( xPortStartScheduler() != pdFALSE )
   2038          		{
   2039          			/* Should not reach here as if the scheduler is running the
   2040          			function will not return. */
   2041          		}
   2042          		else
   2043          		{
   2044          			/* Should only reach here if a task calls xTaskEndScheduler(). */
   2045          		}
   2046          	}
   2047          	else
   2048          	{
   2049          		/* This line will only be reached if the kernel could not be started,
   2050          		because there was not enough FreeRTOS heap to create the idle task
   2051          		or the timer task. */
   2052          		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
   2053          	}
   2054          
   2055          	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
   2056          	meaning xIdleTaskHandle is not used anywhere else. */
   2057          	( void ) xIdleTaskHandle;
   2058          }
   2059          /*-----------------------------------------------------------*/
   2060          
   2061          void vTaskEndScheduler( void )
   2062          {
   2063          	/* Stop the scheduler interrupts and call the portable scheduler end
   2064          	routine so the original ISRs can be restored if necessary.  The port
   2065          	layer must ensure interrupts enable	bit is left in the correct state. */
   2066          	portDISABLE_INTERRUPTS();
   2067          	xSchedulerRunning = pdFALSE;
   2068          	vPortEndScheduler();
   2069          }
   2070          /*----------------------------------------------------------*/
   2071          
   2072          void vTaskSuspendAll( void )
   2073          {
   2074          	/* A critical section is not required as the variable is of type
   2075          	BaseType_t.  Please read Richard Barry's reply in the following link to a
   2076          	post in the FreeRTOS support forum before reporting this as a bug! -
   2077          	http://goo.gl/wu4acr */
   2078          	++uxSchedulerSuspended;
   2079          }
   2080          /*----------------------------------------------------------*/
   2081          
   2082          #if ( configUSE_TICKLESS_IDLE != 0 )
   2083          
   2084          	static TickType_t prvGetExpectedIdleTime( void )
   2085          	{
   2086          	TickType_t xReturn;
   2087          	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
   2088          
   2089          		/* uxHigherPriorityReadyTasks takes care of the case where
   2090          		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
   2091          		task that are in the Ready state, even though the idle task is
   2092          		running. */
   2093          		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
   2094          		{
   2095          			if( uxTopReadyPriority > tskIDLE_PRIORITY )
   2096          			{
   2097          				uxHigherPriorityReadyTasks = pdTRUE;
   2098          			}
   2099          		}
   2100          		#else
   2101          		{
   2102          			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
   2103          
   2104          			/* When port optimised task selection is used the uxTopReadyPriority
   2105          			variable is used as a bit map.  If bits other than the least
   2106          			significant bit are set then there are tasks that have a priority
   2107          			above the idle priority that are in the Ready state.  This takes
   2108          			care of the case where the co-operative scheduler is in use. */
   2109          			if( uxTopReadyPriority > uxLeastSignificantBit )
   2110          			{
   2111          				uxHigherPriorityReadyTasks = pdTRUE;
   2112          			}
   2113          		}
   2114          		#endif
   2115          
   2116          		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
   2117          		{
   2118          			xReturn = 0;
   2119          		}
   2120          		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
   2121          		{
   2122          			/* There are other idle priority tasks in the ready state.  If
   2123          			time slicing is used then the very next tick interrupt must be
   2124          			processed. */
   2125          			xReturn = 0;
   2126          		}
   2127          		else if( uxHigherPriorityReadyTasks != pdFALSE )
   2128          		{
   2129          			/* There are tasks in the Ready state that have a priority above the
   2130          			idle priority.  This path can only be reached if
   2131          			configUSE_PREEMPTION is 0. */
   2132          			xReturn = 0;
   2133          		}
   2134          		else
   2135          		{
   2136          			xReturn = xNextTaskUnblockTime - xTickCount;
   2137          		}
   2138          
   2139          		return xReturn;
   2140          	}
   2141          
   2142          #endif /* configUSE_TICKLESS_IDLE */
   2143          /*----------------------------------------------------------*/
   2144          
   2145          BaseType_t xTaskResumeAll( void )
   2146          {
   2147          TCB_t *pxTCB = NULL;
   2148          BaseType_t xAlreadyYielded = pdFALSE;
   2149          
   2150          	/* If uxSchedulerSuspended is zero then this function does not match a
   2151          	previous call to vTaskSuspendAll(). */
   2152          	configASSERT( uxSchedulerSuspended );
   2153          
   2154          	/* It is possible that an ISR caused a task to be removed from an event
   2155          	list while the scheduler was suspended.  If this was the case then the
   2156          	removed task will have been added to the xPendingReadyList.  Once the
   2157          	scheduler has been resumed it is safe to move all the pending ready
   2158          	tasks from this list into their appropriate ready list. */
   2159          	taskENTER_CRITICAL();
   2160          	{
   2161          		--uxSchedulerSuspended;
   2162          
   2163          		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   2164          		{
   2165          			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   2166          			{
   2167          				/* Move any readied tasks from the pending list into the
   2168          				appropriate ready list. */
   2169          				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   2170          				{
   2171          					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   2172          					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   2173          					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   2174          					prvAddTaskToReadyList( pxTCB );
   2175          
   2176          					/* If the moved task has a priority higher than the current
   2177          					task then a yield must be performed. */
   2178          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   2179          					{
   2180          						xYieldPending = pdTRUE;
   2181          					}
   2182          					else
   2183          					{
   2184          						mtCOVERAGE_TEST_MARKER();
   2185          					}
   2186          				}
   2187          
   2188          				if( pxTCB != NULL )
   2189          				{
   2190          					/* A task was unblocked while the scheduler was suspended,
   2191          					which may have prevented the next unblock time from being
   2192          					re-calculated, in which case re-calculate it now.  Mainly
   2193          					important for low power tickless implementations, where
   2194          					this can prevent an unnecessary exit from low power
   2195          					state. */
   2196          					prvResetNextTaskUnblockTime();
   2197          				}
   2198          
   2199          				/* If any ticks occurred while the scheduler was suspended then
   2200          				they should be processed now.  This ensures the tick count does
   2201          				not	slip, and that any delayed tasks are resumed at the correct
   2202          				time. */
   2203          				{
   2204          					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
   2205          
   2206          					if( uxPendedCounts > ( UBaseType_t ) 0U )
   2207          					{
   2208          						do
   2209          						{
   2210          							if( xTaskIncrementTick() != pdFALSE )
   2211          							{
   2212          								xYieldPending = pdTRUE;
   2213          							}
   2214          							else
   2215          							{
   2216          								mtCOVERAGE_TEST_MARKER();
   2217          							}
   2218          							--uxPendedCounts;
   2219          						} while( uxPendedCounts > ( UBaseType_t ) 0U );
   2220          
   2221          						uxPendedTicks = 0;
   2222          					}
   2223          					else
   2224          					{
   2225          						mtCOVERAGE_TEST_MARKER();
   2226          					}
   2227          				}
   2228          
   2229          				if( xYieldPending != pdFALSE )
   2230          				{
   2231          					#if( configUSE_PREEMPTION != 0 )
   2232          					{
   2233          						xAlreadyYielded = pdTRUE;
   2234          					}
   2235          					#endif
   2236          					taskYIELD_IF_USING_PREEMPTION();
   2237          				}
   2238          				else
   2239          				{
   2240          					mtCOVERAGE_TEST_MARKER();
   2241          				}
   2242          			}
   2243          		}
   2244          		else
   2245          		{
   2246          			mtCOVERAGE_TEST_MARKER();
   2247          		}
   2248          	}
   2249          	taskEXIT_CRITICAL();
   2250          
   2251          	return xAlreadyYielded;
   2252          }
   2253          /*-----------------------------------------------------------*/
   2254          
   2255          TickType_t xTaskGetTickCount( void )
   2256          {
   2257          TickType_t xTicks;
   2258          
   2259          	/* Critical section required if running on a 16 bit processor. */
   2260          	portTICK_TYPE_ENTER_CRITICAL();
   2261          	{
   2262          		xTicks = xTickCount;
   2263          	}
   2264          	portTICK_TYPE_EXIT_CRITICAL();
   2265          
   2266          	return xTicks;
   2267          }
   2268          /*-----------------------------------------------------------*/
   2269          
   2270          TickType_t xTaskGetTickCountFromISR( void )
   2271          {
   2272          TickType_t xReturn;
   2273          UBaseType_t uxSavedInterruptStatus;
   2274          
   2275          	/* RTOS ports that support interrupt nesting have the concept of a maximum
   2276          	system call (or maximum API call) interrupt priority.  Interrupts that are
   2277          	above the maximum system call priority are kept permanently enabled, even
   2278          	when the RTOS kernel is in a critical section, but cannot make any calls to
   2279          	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
   2280          	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   2281          	failure if a FreeRTOS API function is called from an interrupt that has been
   2282          	assigned a priority above the configured maximum system call priority.
   2283          	Only FreeRTOS functions that end in FromISR can be called from interrupts
   2284          	that have been assigned a priority at or (logically) below the maximum
   2285          	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
   2286          	safe API to ensure interrupt entry is as fast and as simple as possible.
   2287          	More information (albeit Cortex-M specific) is provided on the following
   2288          	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
   2289          	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   2290          
   2291          	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
   2292          	{
   2293          		xReturn = xTickCount;
   2294          	}
   2295          	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   2296          
   2297          	return xReturn;
   2298          }
   2299          /*-----------------------------------------------------------*/
   2300          
   2301          UBaseType_t uxTaskGetNumberOfTasks( void )
   2302          {
   2303          	/* A critical section is not required because the variables are of type
   2304          	BaseType_t. */
   2305          	return uxCurrentNumberOfTasks;
   2306          }
   2307          /*-----------------------------------------------------------*/
   2308          
   2309          char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   2310          {
   2311          TCB_t *pxTCB;
   2312          
   2313          	/* If null is passed in here then the name of the calling task is being
   2314          	queried. */
   2315          	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
   2316          	configASSERT( pxTCB );
   2317          	return &( pxTCB->pcTaskName[ 0 ] );
   2318          }
   2319          /*-----------------------------------------------------------*/
   2320          
   2321          #if ( INCLUDE_xTaskGetHandle == 1 )
   2322          
   2323          	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
   2324          	{
   2325          	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
   2326          	UBaseType_t x;
   2327          	char cNextChar;
   2328          	BaseType_t xBreakLoop;
   2329          
   2330          		/* This function is called with the scheduler suspended. */
   2331          
   2332          		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
   2333          		{
   2334          			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );  /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   2335          
   2336          			do
   2337          			{
   2338          				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   2339          
   2340          				/* Check each character in the name looking for a match or
   2341          				mismatch. */
   2342          				xBreakLoop = pdFALSE;
   2343          				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   2344          				{
   2345          					cNextChar = pxNextTCB->pcTaskName[ x ];
   2346          
   2347          					if( cNextChar != pcNameToQuery[ x ] )
   2348          					{
   2349          						/* Characters didn't match. */
   2350          						xBreakLoop = pdTRUE;
   2351          					}
   2352          					else if( cNextChar == ( char ) 0x00 )
   2353          					{
   2354          						/* Both strings terminated, a match must have been
   2355          						found. */
   2356          						pxReturn = pxNextTCB;
   2357          						xBreakLoop = pdTRUE;
   2358          					}
   2359          					else
   2360          					{
   2361          						mtCOVERAGE_TEST_MARKER();
   2362          					}
   2363          
   2364          					if( xBreakLoop != pdFALSE )
   2365          					{
   2366          						break;
   2367          					}
   2368          				}
   2369          
   2370          				if( pxReturn != NULL )
   2371          				{
   2372          					/* The handle has been found. */
   2373          					break;
   2374          				}
   2375          
   2376          			} while( pxNextTCB != pxFirstTCB );
   2377          		}
   2378          		else
   2379          		{
   2380          			mtCOVERAGE_TEST_MARKER();
   2381          		}
   2382          
   2383          		return pxReturn;
   2384          	}
   2385          
   2386          #endif /* INCLUDE_xTaskGetHandle */
   2387          /*-----------------------------------------------------------*/
   2388          
   2389          #if ( INCLUDE_xTaskGetHandle == 1 )
   2390          
   2391          	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   2392          	{
   2393          	UBaseType_t uxQueue = configMAX_PRIORITIES;
   2394          	TCB_t* pxTCB;
   2395          
   2396          		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
   2397          		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
   2398          
   2399          		vTaskSuspendAll();
   2400          		{
   2401          			/* Search the ready lists. */
   2402          			do
   2403          			{
   2404          				uxQueue--;
   2405          				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNameToQuery );
   2406          
   2407          				if( pxTCB != NULL )
   2408          				{
   2409          					/* Found the handle. */
   2410          					break;
   2411          				}
   2412          
   2413          			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   2414          
   2415          			/* Search the delayed lists. */
   2416          			if( pxTCB == NULL )
   2417          			{
   2418          				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
   2419          			}
   2420          
   2421          			if( pxTCB == NULL )
   2422          			{
   2423          				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery );
   2424          			}
   2425          
   2426          			#if ( INCLUDE_vTaskSuspend == 1 )
   2427          			{
   2428          				if( pxTCB == NULL )
   2429          				{
   2430          					/* Search the suspended list. */
   2431          					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
   2432          				}
   2433          			}
   2434          			#endif
   2435          
   2436          			#if( INCLUDE_vTaskDelete == 1 )
   2437          			{
   2438          				if( pxTCB == NULL )
   2439          				{
   2440          					/* Search the deleted list. */
   2441          					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
   2442          				}
   2443          			}
   2444          			#endif
   2445          		}
   2446          		( void ) xTaskResumeAll();
   2447          
   2448          		return pxTCB;
   2449          	}
   2450          
   2451          #endif /* INCLUDE_xTaskGetHandle */
   2452          /*-----------------------------------------------------------*/
   2453          
   2454          #if ( configUSE_TRACE_FACILITY == 1 )
   2455          
   2456          	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
   2457          	{
   2458          	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
   2459          
   2460          		vTaskSuspendAll();
   2461          		{
   2462          			/* Is there a space in the array for each task in the system? */
   2463          			if( uxArraySize >= uxCurrentNumberOfTasks )
   2464          			{
   2465          				/* Fill in an TaskStatus_t structure with information on each
   2466          				task in the Ready state. */
   2467          				do
   2468          				{
   2469          					uxQueue--;
   2470          					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
   2471          
   2472          				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   2473          
   2474          				/* Fill in an TaskStatus_t structure with information on each
   2475          				task in the Blocked state. */
   2476          				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
   2477          				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
   2478          
   2479          				#if( INCLUDE_vTaskDelete == 1 )
   2480          				{
   2481          					/* Fill in an TaskStatus_t structure with information on
   2482          					each task that has been deleted but not yet cleaned up. */
   2483          					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
   2484          				}
   2485          				#endif
   2486          
   2487          				#if ( INCLUDE_vTaskSuspend == 1 )
   2488          				{
   2489          					/* Fill in an TaskStatus_t structure with information on
   2490          					each task in the Suspended state. */
   2491          					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
   2492          				}
   2493          				#endif
   2494          
   2495          				#if ( configGENERATE_RUN_TIME_STATS == 1)
   2496          				{
   2497          					if( pulTotalRunTime != NULL )
   2498          					{
   2499          						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
   2500          							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
   2501          						#else
   2502          							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   2503          						#endif
   2504          					}
   2505          				}
   2506          				#else
   2507          				{
   2508          					if( pulTotalRunTime != NULL )
   2509          					{
   2510          						*pulTotalRunTime = 0;
   2511          					}
   2512          				}
   2513          				#endif
   2514          			}
   2515          			else
   2516          			{
   2517          				mtCOVERAGE_TEST_MARKER();
   2518          			}
   2519          		}
   2520          		( void ) xTaskResumeAll();
   2521          
   2522          		return uxTask;
   2523          	}
   2524          
   2525          #endif /* configUSE_TRACE_FACILITY */
   2526          /*----------------------------------------------------------*/
   2527          
   2528          #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
   2529          
   2530          	TaskHandle_t xTaskGetIdleTaskHandle( void )
   2531          	{
   2532          		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
   2533          		started, then xIdleTaskHandle will be NULL. */
   2534          		configASSERT( ( xIdleTaskHandle != NULL ) );
   2535          		return xIdleTaskHandle;
   2536          	}
   2537          
   2538          #endif /* INCLUDE_xTaskGetIdleTaskHandle */
   2539          /*----------------------------------------------------------*/
   2540          
   2541          /* This conditional compilation should use inequality to 0, not equality to 1.
   2542          This is to ensure vTaskStepTick() is available when user defined low power mode
   2543          implementations require configUSE_TICKLESS_IDLE to be set to a value other than
   2544          1. */
   2545          #if ( configUSE_TICKLESS_IDLE != 0 )
   2546          
   2547          	void vTaskStepTick( const TickType_t xTicksToJump )
   2548          	{
   2549          		/* Correct the tick count value after a period during which the tick
   2550          		was suppressed.  Note this does *not* call the tick hook function for
   2551          		each stepped tick. */
   2552          		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
   2553          		xTickCount += xTicksToJump;
   2554          		traceINCREASE_TICK_COUNT( xTicksToJump );
   2555          	}
   2556          
   2557          #endif /* configUSE_TICKLESS_IDLE */
   2558          /*----------------------------------------------------------*/
   2559          
   2560          #if ( INCLUDE_xTaskAbortDelay == 1 )
   2561          
   2562          	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
   2563          	{
   2564          	TCB_t *pxTCB = xTask;
   2565          	BaseType_t xReturn;
   2566          
   2567          		configASSERT( pxTCB );
   2568          
   2569          		vTaskSuspendAll();
   2570          		{
   2571          			/* A task can only be prematurely removed from the Blocked state if
   2572          			it is actually in the Blocked state. */
   2573          			if( eTaskGetState( xTask ) == eBlocked )
   2574          			{
   2575          				xReturn = pdPASS;
   2576          
   2577          				/* Remove the reference to the task from the blocked list.  An
   2578          				interrupt won't touch the xStateListItem because the
   2579          				scheduler is suspended. */
   2580          				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   2581          
   2582          				/* Is the task waiting on an event also?  If so remove it from
   2583          				the event list too.  Interrupts can touch the event list item,
   2584          				even though the scheduler is suspended, so a critical section
   2585          				is used. */
   2586          				taskENTER_CRITICAL();
   2587          				{
   2588          					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   2589          					{
   2590          						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   2591          						pxTCB->ucDelayAborted = pdTRUE;
   2592          					}
   2593          					else
   2594          					{
   2595          						mtCOVERAGE_TEST_MARKER();
   2596          					}
   2597          				}
   2598          				taskEXIT_CRITICAL();
   2599          
   2600          				/* Place the unblocked task into the appropriate ready list. */
   2601          				prvAddTaskToReadyList( pxTCB );
   2602          
   2603          				/* A task being unblocked cannot cause an immediate context
   2604          				switch if preemption is turned off. */
   2605          				#if (  configUSE_PREEMPTION == 1 )
   2606          				{
   2607          					/* Preemption is on, but a context switch should only be
   2608          					performed if the unblocked task has a priority that is
   2609          					equal to or higher than the currently executing task. */
   2610          					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   2611          					{
   2612          						/* Pend the yield to be performed when the scheduler
   2613          						is unsuspended. */
   2614          						xYieldPending = pdTRUE;
   2615          					}
   2616          					else
   2617          					{
   2618          						mtCOVERAGE_TEST_MARKER();
   2619          					}
   2620          				}
   2621          				#endif /* configUSE_PREEMPTION */
   2622          			}
   2623          			else
   2624          			{
   2625          				xReturn = pdFAIL;
   2626          			}
   2627          		}
   2628          		( void ) xTaskResumeAll();
   2629          
   2630          		return xReturn;
   2631          	}
   2632          
   2633          #endif /* INCLUDE_xTaskAbortDelay */
   2634          /*----------------------------------------------------------*/
   2635          
   2636          BaseType_t xTaskIncrementTick( void )
   2637          {
   2638          TCB_t * pxTCB;
   2639          TickType_t xItemValue;
   2640          BaseType_t xSwitchRequired = pdFALSE;
   2641          
   2642          	/* Called by the portable layer each time a tick interrupt occurs.
   2643          	Increments the tick then checks to see if the new tick value will cause any
   2644          	tasks to be unblocked. */
   2645          	traceTASK_INCREMENT_TICK( xTickCount );
   2646          	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   2647          	{
   2648          		/* Minor optimisation.  The tick count cannot change in this
   2649          		block. */
   2650          		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
   2651          
   2652          		/* Increment the RTOS tick, switching the delayed and overflowed
   2653          		delayed lists if it wraps to 0. */
   2654          		xTickCount = xConstTickCount;
   2655          
   2656          		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
   2657          		{
   2658          			taskSWITCH_DELAYED_LISTS();
   2659          		}
   2660          		else
   2661          		{
   2662          			mtCOVERAGE_TEST_MARKER();
   2663          		}
   2664          
   2665          		/* See if this tick has made a timeout expire.  Tasks are stored in
   2666          		the	queue in the order of their wake time - meaning once one task
   2667          		has been found whose block time has not expired there is no need to
   2668          		look any further down the list. */
   2669          		if( xConstTickCount >= xNextTaskUnblockTime )
   2670          		{
   2671          			for( ;; )
   2672          			{
   2673          				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   2674          				{
   2675          					/* The delayed list is empty.  Set xNextTaskUnblockTime
   2676          					to the maximum possible value so it is extremely
   2677          					unlikely that the
   2678          					if( xTickCount >= xNextTaskUnblockTime ) test will pass
   2679          					next time through. */
   2680          					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   2681          					break;
   2682          				}
   2683          				else
   2684          				{
   2685          					/* The delayed list is not empty, get the value of the
   2686          					item at the head of the delayed list.  This is the time
   2687          					at which the task at the head of the delayed list must
   2688          					be removed from the Blocked state. */
   2689          					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   2690          					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
   2691          
   2692          					if( xConstTickCount < xItemValue )
   2693          					{
   2694          						/* It is not time to unblock this item yet, but the
   2695          						item value is the time at which the task at the head
   2696          						of the blocked list must be removed from the Blocked
   2697          						state -	so record the item value in
   2698          						xNextTaskUnblockTime. */
   2699          						xNextTaskUnblockTime = xItemValue;
   2700          						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
   2701          					}
   2702          					else
   2703          					{
   2704          						mtCOVERAGE_TEST_MARKER();
   2705          					}
   2706          
   2707          					/* It is time to remove the item from the Blocked state. */
   2708          					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   2709          
   2710          					/* Is the task waiting on an event also?  If so remove
   2711          					it from the event list. */
   2712          					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   2713          					{
   2714          						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   2715          					}
   2716          					else
   2717          					{
   2718          						mtCOVERAGE_TEST_MARKER();
   2719          					}
   2720          
   2721          					/* Place the unblocked task into the appropriate ready
   2722          					list. */
   2723          					prvAddTaskToReadyList( pxTCB );
   2724          
   2725          					/* A task being unblocked cannot cause an immediate
   2726          					context switch if preemption is turned off. */
   2727          					#if (  configUSE_PREEMPTION == 1 )
   2728          					{
   2729          						/* Preemption is on, but a context switch should
   2730          						only be performed if the unblocked task has a
   2731          						priority that is equal to or higher than the
   2732          						currently executing task. */
   2733          						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   2734          						{
   2735          							xSwitchRequired = pdTRUE;
   2736          						}
   2737          						else
   2738          						{
   2739          							mtCOVERAGE_TEST_MARKER();
   2740          						}
   2741          					}
   2742          					#endif /* configUSE_PREEMPTION */
   2743          				}
   2744          			}
   2745          		}
   2746          
   2747          		/* Tasks of equal priority to the currently running task will share
   2748          		processing time (time slice) if preemption is on, and the application
   2749          		writer has not explicitly turned time slicing off. */
   2750          		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
   2751          		{
   2752          			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   2753          			{
   2754          				xSwitchRequired = pdTRUE;
   2755          			}
   2756          			else
   2757          			{
   2758          				mtCOVERAGE_TEST_MARKER();
   2759          			}
   2760          		}
   2761          		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
   2762          
   2763          		#if ( configUSE_TICK_HOOK == 1 )
   2764          		{
   2765          			/* Guard against the tick hook being called when the pended tick
   2766          			count is being unwound (when the scheduler is being unlocked). */
   2767          			if( uxPendedTicks == ( UBaseType_t ) 0U )
   2768          			{
   2769          				vApplicationTickHook();
   2770          			}
   2771          			else
   2772          			{
   2773          				mtCOVERAGE_TEST_MARKER();
   2774          			}
   2775          		}
   2776          		#endif /* configUSE_TICK_HOOK */
   2777          	}
   2778          	else
   2779          	{
   2780          		++uxPendedTicks;
   2781          
   2782          		/* The tick hook gets called at regular intervals, even if the
   2783          		scheduler is locked. */
   2784          		#if ( configUSE_TICK_HOOK == 1 )
   2785          		{
   2786          			vApplicationTickHook();
   2787          		}
   2788          		#endif
   2789          	}
   2790          
   2791          	#if ( configUSE_PREEMPTION == 1 )
   2792          	{
   2793          		if( xYieldPending != pdFALSE )
   2794          		{
   2795          			xSwitchRequired = pdTRUE;
   2796          		}
   2797          		else
   2798          		{
   2799          			mtCOVERAGE_TEST_MARKER();
   2800          		}
   2801          	}
   2802          	#endif /* configUSE_PREEMPTION */
   2803          
   2804          	return xSwitchRequired;
   2805          }
   2806          /*-----------------------------------------------------------*/
   2807          
   2808          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2809          
   2810          	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
   2811          	{
   2812          	TCB_t *xTCB;
   2813          
   2814          		/* If xTask is NULL then it is the task hook of the calling task that is
   2815          		getting set. */
   2816          		if( xTask == NULL )
   2817          		{
   2818          			xTCB = ( TCB_t * ) pxCurrentTCB;
   2819          		}
   2820          		else
   2821          		{
   2822          			xTCB = xTask;
   2823          		}
   2824          
   2825          		/* Save the hook function in the TCB.  A critical section is required as
   2826          		the value can be accessed from an interrupt. */
   2827          		taskENTER_CRITICAL();
   2828          		{
   2829          			xTCB->pxTaskTag = pxHookFunction;
   2830          		}
   2831          		taskEXIT_CRITICAL();
   2832          	}
   2833          
   2834          #endif /* configUSE_APPLICATION_TASK_TAG */
   2835          /*-----------------------------------------------------------*/
   2836          
   2837          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2838          
   2839          	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
   2840          	{
   2841          	TCB_t *xTCB;
   2842          	TaskHookFunction_t xReturn;
   2843          
   2844          		/* If xTask is NULL then we are setting our own task hook. */
   2845          		if( xTask == NULL )
   2846          		{
   2847          			xTCB = ( TCB_t * ) pxCurrentTCB;
   2848          		}
   2849          		else
   2850          		{
   2851          			xTCB = xTask;
   2852          		}
   2853          
   2854          		/* Save the hook function in the TCB.  A critical section is required as
   2855          		the value can be accessed from an interrupt. */
   2856          		taskENTER_CRITICAL();
   2857          		{
   2858          			xReturn = xTCB->pxTaskTag;
   2859          		}
   2860          		taskEXIT_CRITICAL();
   2861          
   2862          		return xReturn;
   2863          	}
   2864          
   2865          #endif /* configUSE_APPLICATION_TASK_TAG */
   2866          /*-----------------------------------------------------------*/
   2867          
   2868          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2869          
   2870          	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
   2871          	{
   2872          	TCB_t *xTCB;
   2873          	BaseType_t xReturn;
   2874          
   2875          		/* If xTask is NULL then we are calling our own task hook. */
   2876          		if( xTask == NULL )
   2877          		{
   2878          			xTCB = pxCurrentTCB;
   2879          		}
   2880          		else
   2881          		{
   2882          			xTCB = xTask;
   2883          		}
   2884          
   2885          		if( xTCB->pxTaskTag != NULL )
   2886          		{
   2887          			xReturn = xTCB->pxTaskTag( pvParameter );
   2888          		}
   2889          		else
   2890          		{
   2891          			xReturn = pdFAIL;
   2892          		}
   2893          
   2894          		return xReturn;
   2895          	}
   2896          
   2897          #endif /* configUSE_APPLICATION_TASK_TAG */
   2898          /*-----------------------------------------------------------*/
   2899          
   2900          void vTaskSwitchContext( void )
   2901          {
   2902          	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   2903          	{
   2904          		/* The scheduler is currently suspended - do not allow a context
   2905          		switch. */
   2906          		xYieldPending = pdTRUE;
   2907          	}
   2908          	else
   2909          	{
   2910          		xYieldPending = pdFALSE;
   2911          		traceTASK_SWITCHED_OUT();
   2912          
   2913          		#if ( configGENERATE_RUN_TIME_STATS == 1 )
   2914          		{
   2915          				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
   2916          					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
   2917          				#else
   2918          					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   2919          				#endif
   2920          
   2921          				/* Add the amount of time the task has been running to the
   2922          				accumulated time so far.  The time the task started running was
   2923          				stored in ulTaskSwitchedInTime.  Note that there is no overflow
   2924          				protection here so count values are only valid until the timer
   2925          				overflows.  The guard against negative values is to protect
   2926          				against suspect run time stat counter implementations - which
   2927          				are provided by the application, not the kernel. */
   2928          				if( ulTotalRunTime > ulTaskSwitchedInTime )
   2929          				{
   2930          					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
   2931          				}
   2932          				else
   2933          				{
   2934          					mtCOVERAGE_TEST_MARKER();
   2935          				}
   2936          				ulTaskSwitchedInTime = ulTotalRunTime;
   2937          		}
   2938          		#endif /* configGENERATE_RUN_TIME_STATS */
   2939          
   2940          		/* Check for stack overflow, if configured. */
   2941          		taskCHECK_FOR_STACK_OVERFLOW();
   2942          
   2943          		/* Before the currently running task is switched out, save its errno. */
   2944          		#if( configUSE_POSIX_ERRNO == 1 )
   2945          		{
   2946          			pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
   2947          		}
   2948          		#endif
   2949          
   2950          		/* Select a new task to run using either the generic C or port
   2951          		optimised asm code. */
   2952          		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   2953          		traceTASK_SWITCHED_IN();
   2954          
   2955          		/* After the new task is switched in, update the global errno. */
   2956          		#if( configUSE_POSIX_ERRNO == 1 )
   2957          		{
   2958          			FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
   2959          		}
   2960          		#endif
   2961          
   2962          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   2963          		{
   2964          			/* Switch Newlib's _impure_ptr variable to point to the _reent
   2965          			structure specific to this task. */
   2966          			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
   2967          		}
   2968          		#endif /* configUSE_NEWLIB_REENTRANT */
   2969          	}
   2970          }
   2971          /*-----------------------------------------------------------*/
   2972          
   2973          void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
   2974          {
   2975          	configASSERT( pxEventList );
   2976          
   2977          	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
   2978          	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
   2979          
   2980          	/* Place the event list item of the TCB in the appropriate event list.
   2981          	This is placed in the list in priority order so the highest priority task
   2982          	is the first to be woken by the event.  The queue that contains the event
   2983          	list is locked, preventing simultaneous access from interrupts. */
   2984          	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   2985          
   2986          	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   2987          }
   2988          /*-----------------------------------------------------------*/
   2989          
   2990          void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
   2991          {
   2992          	configASSERT( pxEventList );
   2993          
   2994          	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
   2995          	the event groups implementation. */
   2996          	configASSERT( uxSchedulerSuspended != 0 );
   2997          
   2998          	/* Store the item value in the event list item.  It is safe to access the
   2999          	event list item here as interrupts won't access the event list item of a
   3000          	task that is not in the Blocked state. */
   3001          	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   3002          
   3003          	/* Place the event list item of the TCB at the end of the appropriate event
   3004          	list.  It is safe to access the event list here because it is part of an
   3005          	event group implementation - and interrupts don't access event groups
   3006          	directly (instead they access them indirectly by pending function calls to
   3007          	the task level). */
   3008          	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   3009          
   3010          	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   3011          }
   3012          /*-----------------------------------------------------------*/
   3013          
   3014          #if( configUSE_TIMERS == 1 )
   3015          
   3016          	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
   3017          	{
   3018          		configASSERT( pxEventList );
   3019          
   3020          		/* This function should not be called by application code hence the
   3021          		'Restricted' in its name.  It is not part of the public API.  It is
   3022          		designed for use by kernel code, and has special calling requirements -
   3023          		it should be called with the scheduler suspended. */
   3024          
   3025          
   3026          		/* Place the event list item of the TCB in the appropriate event list.
   3027          		In this case it is assume that this is the only task that is going to
   3028          		be waiting on this event list, so the faster vListInsertEnd() function
   3029          		can be used in place of vListInsert. */
   3030          		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   3031          
   3032          		/* If the task should block indefinitely then set the block time to a
   3033          		value that will be recognised as an indefinite delay inside the
   3034          		prvAddCurrentTaskToDelayedList() function. */
   3035          		if( xWaitIndefinitely != pdFALSE )
   3036          		{
   3037          			xTicksToWait = portMAX_DELAY;
   3038          		}
   3039          
   3040          		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
   3041          		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
   3042          	}
   3043          
   3044          #endif /* configUSE_TIMERS */
   3045          /*-----------------------------------------------------------*/
   3046          
   3047          BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
   3048          {
   3049          TCB_t *pxUnblockedTCB;
   3050          BaseType_t xReturn;
   3051          
   3052          	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
   3053          	called from a critical section within an ISR. */
   3054          
   3055          	/* The event list is sorted in priority order, so the first in the list can
   3056          	be removed as it is known to be the highest priority.  Remove the TCB from
   3057          	the delayed list, and add it to the ready list.
   3058          
   3059          	If an event is for a queue that is locked then this function will never
   3060          	get called - the lock count on the queue will get modified instead.  This
   3061          	means exclusive access to the event list is guaranteed here.
   3062          
   3063          	This function assumes that a check has already been made to ensure that
   3064          	pxEventList is not empty. */
   3065          	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   3066          	configASSERT( pxUnblockedTCB );
   3067          	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   3068          
   3069          	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   3070          	{
   3071          		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   3072          		prvAddTaskToReadyList( pxUnblockedTCB );
   3073          	}
   3074          	else
   3075          	{
   3076          		/* The delayed and ready lists cannot be accessed, so hold this task
   3077          		pending until the scheduler is resumed. */
   3078          		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   3079          	}
   3080          
   3081          	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   3082          	{
   3083          		/* Return true if the task removed from the event list has a higher
   3084          		priority than the calling task.  This allows the calling task to know if
   3085          		it should force a context switch now. */
   3086          		xReturn = pdTRUE;
   3087          
   3088          		/* Mark that a yield is pending in case the user is not using the
   3089          		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
   3090          		xYieldPending = pdTRUE;
   3091          	}
   3092          	else
   3093          	{
   3094          		xReturn = pdFALSE;
   3095          	}
   3096          
   3097          	#if( configUSE_TICKLESS_IDLE != 0 )
   3098          	{
   3099          		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
   3100          		might be set to the blocked task's time out time.  If the task is
   3101          		unblocked for a reason other than a timeout xNextTaskUnblockTime is
   3102          		normally left unchanged, because it is automatically reset to a new
   3103          		value when the tick count equals xNextTaskUnblockTime.  However if
   3104          		tickless idling is used it might be more important to enter sleep mode
   3105          		at the earliest possible time - so reset xNextTaskUnblockTime here to
   3106          		ensure it is updated at the earliest possible time. */
   3107          		prvResetNextTaskUnblockTime();
   3108          	}
   3109          	#endif
   3110          
   3111          	return xReturn;
   3112          }
   3113          /*-----------------------------------------------------------*/
   3114          
   3115          void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
   3116          {
   3117          TCB_t *pxUnblockedTCB;
   3118          
   3119          	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
   3120          	the event flags implementation. */
   3121          	configASSERT( uxSchedulerSuspended != pdFALSE );
   3122          
   3123          	/* Store the new item value in the event list. */
   3124          	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   3125          
   3126          	/* Remove the event list form the event flag.  Interrupts do not access
   3127          	event flags. */
   3128          	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   3129          	configASSERT( pxUnblockedTCB );
   3130          	( void ) uxListRemove( pxEventListItem );
   3131          
   3132          	/* Remove the task from the delayed list and add it to the ready list.  The
   3133          	scheduler is suspended so interrupts will not be accessing the ready
   3134          	lists. */
   3135          	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   3136          	prvAddTaskToReadyList( pxUnblockedTCB );
   3137          
   3138          	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   3139          	{
   3140          		/* The unblocked task has a priority above that of the calling task, so
   3141          		a context switch is required.  This function is called with the
   3142          		scheduler suspended so xYieldPending is set so the context switch
   3143          		occurs immediately that the scheduler is resumed (unsuspended). */
   3144          		xYieldPending = pdTRUE;
   3145          	}
   3146          }
   3147          /*-----------------------------------------------------------*/
   3148          
   3149          void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
   3150          {
   3151          	configASSERT( pxTimeOut );
   3152          	taskENTER_CRITICAL();
   3153          	{
   3154          		pxTimeOut->xOverflowCount = xNumOfOverflows;
   3155          		pxTimeOut->xTimeOnEntering = xTickCount;
   3156          	}
   3157          	taskEXIT_CRITICAL();
   3158          }
   3159          /*-----------------------------------------------------------*/
   3160          
   3161          void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
   3162          {
   3163          	/* For internal use only as it does not use a critical section. */
   3164          	pxTimeOut->xOverflowCount = xNumOfOverflows;
   3165          	pxTimeOut->xTimeOnEntering = xTickCount;
   3166          }
   3167          /*-----------------------------------------------------------*/
   3168          
   3169          BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
   3170          {
   3171          BaseType_t xReturn;
   3172          
   3173          	configASSERT( pxTimeOut );
   3174          	configASSERT( pxTicksToWait );
   3175          
   3176          	taskENTER_CRITICAL();
   3177          	{
   3178          		/* Minor optimisation.  The tick count cannot change in this block. */
   3179          		const TickType_t xConstTickCount = xTickCount;
   3180          		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
   3181          
   3182          		#if( INCLUDE_xTaskAbortDelay == 1 )
   3183          			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
   3184          			{
   3185          				/* The delay was aborted, which is not the same as a time out,
   3186          				but has the same result. */
   3187          				pxCurrentTCB->ucDelayAborted = pdFALSE;
   3188          				xReturn = pdTRUE;
   3189          			}
   3190          			else
   3191          		#endif
   3192          
   3193          		#if ( INCLUDE_vTaskSuspend == 1 )
   3194          			if( *pxTicksToWait == portMAX_DELAY )
   3195          			{
   3196          				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
   3197          				specified is the maximum block time then the task should block
   3198          				indefinitely, and therefore never time out. */
   3199          				xReturn = pdFALSE;
   3200          			}
   3201          			else
   3202          		#endif
   3203          
   3204          		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   3205          		{
   3206          			/* The tick count is greater than the time at which
   3207          			vTaskSetTimeout() was called, but has also overflowed since
   3208          			vTaskSetTimeOut() was called.  It must have wrapped all the way
   3209          			around and gone past again. This passed since vTaskSetTimeout()
   3210          			was called. */
   3211          			xReturn = pdTRUE;
   3212          		}
   3213          		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
   3214          		{
   3215          			/* Not a genuine timeout. Adjust parameters for time remaining. */
   3216          			*pxTicksToWait -= xElapsedTime;
   3217          			vTaskInternalSetTimeOutState( pxTimeOut );
   3218          			xReturn = pdFALSE;
   3219          		}
   3220          		else
   3221          		{
   3222          			*pxTicksToWait = 0;
   3223          			xReturn = pdTRUE;
   3224          		}
   3225          	}
   3226          	taskEXIT_CRITICAL();
   3227          
   3228          	return xReturn;
   3229          }
   3230          /*-----------------------------------------------------------*/
   3231          
   3232          void vTaskMissedYield( void )
   3233          {
   3234          	xYieldPending = pdTRUE;
   3235          }
   3236          /*-----------------------------------------------------------*/
   3237          
   3238          #if ( configUSE_TRACE_FACILITY == 1 )
   3239          
   3240          	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
   3241          	{
   3242          	UBaseType_t uxReturn;
   3243          	TCB_t const *pxTCB;
   3244          
   3245          		if( xTask != NULL )
   3246          		{
   3247          			pxTCB = xTask;
   3248          			uxReturn = pxTCB->uxTaskNumber;
   3249          		}
   3250          		else
   3251          		{
   3252          			uxReturn = 0U;
   3253          		}
   3254          
   3255          		return uxReturn;
   3256          	}
   3257          
   3258          #endif /* configUSE_TRACE_FACILITY */
   3259          /*-----------------------------------------------------------*/
   3260          
   3261          #if ( configUSE_TRACE_FACILITY == 1 )
   3262          
   3263          	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
   3264          	{
   3265          	TCB_t * pxTCB;
   3266          
   3267          		if( xTask != NULL )
   3268          		{
   3269          			pxTCB = xTask;
   3270          			pxTCB->uxTaskNumber = uxHandle;
   3271          		}
   3272          	}
   3273          
   3274          #endif /* configUSE_TRACE_FACILITY */
   3275          
   3276          /*
   3277           * -----------------------------------------------------------
   3278           * The Idle task.
   3279           * ----------------------------------------------------------
   3280           *
   3281           * The portTASK_FUNCTION() macro is used to allow port/compiler specific
   3282           * language extensions.  The equivalent prototype for this function is:
   3283           *
   3284           * void prvIdleTask( void *pvParameters );
   3285           *
   3286           */
   3287          static portTASK_FUNCTION( prvIdleTask, pvParameters )
   3288          {
   3289          	/* Stop warnings. */
   3290          	( void ) pvParameters;
   3291          
   3292          	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
   3293          	SCHEDULER IS STARTED. **/
   3294          
   3295          	/* In case a task that has a secure context deletes itself, in which case
   3296          	the idle task is responsible for deleting the task's secure context, if
   3297          	any. */
   3298          	portTASK_CALLS_SECURE_FUNCTIONS();
   3299          
   3300          	for( ;; )
   3301          	{
   3302          		/* See if any tasks have deleted themselves - if so then the idle task
   3303          		is responsible for freeing the deleted task's TCB and stack. */
   3304          		prvCheckTasksWaitingTermination();
   3305          
   3306          		#if ( configUSE_PREEMPTION == 0 )
   3307          		{
   3308          			/* If we are not using preemption we keep forcing a task switch to
   3309          			see if any other task has become available.  If we are using
   3310          			preemption we don't need to do this as any task becoming available
   3311          			will automatically get the processor anyway. */
   3312          			taskYIELD();
   3313          		}
   3314          		#endif /* configUSE_PREEMPTION */
   3315          
   3316          		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
   3317          		{
   3318          			/* When using preemption tasks of equal priority will be
   3319          			timesliced.  If a task that is sharing the idle priority is ready
   3320          			to run then the idle task should yield before the end of the
   3321          			timeslice.
   3322          
   3323          			A critical region is not required here as we are just reading from
   3324          			the list, and an occasional incorrect value will not matter.  If
   3325          			the ready list at the idle priority contains more than one task
   3326          			then a task other than the idle task is ready to execute. */
   3327          			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
   3328          			{
   3329          				taskYIELD();
   3330          			}
   3331          			else
   3332          			{
   3333          				mtCOVERAGE_TEST_MARKER();
   3334          			}
   3335          		}
   3336          		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
   3337          
   3338          		#if ( configUSE_IDLE_HOOK == 1 )
   3339          		{
   3340          			extern void vApplicationIdleHook( void );
   3341          
   3342          			/* Call the user defined function from within the idle task.  This
   3343          			allows the application designer to add background functionality
   3344          			without the overhead of a separate task.
   3345          			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
   3346          			CALL A FUNCTION THAT MIGHT BLOCK. */
   3347          			vApplicationIdleHook();
   3348          		}
   3349          		#endif /* configUSE_IDLE_HOOK */
   3350          
   3351          		/* This conditional compilation should use inequality to 0, not equality
   3352          		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
   3353          		user defined low power mode	implementations require
   3354          		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
   3355          		#if ( configUSE_TICKLESS_IDLE != 0 )
   3356          		{
   3357          		TickType_t xExpectedIdleTime;
   3358          
   3359          			/* It is not desirable to suspend then resume the scheduler on
   3360          			each iteration of the idle task.  Therefore, a preliminary
   3361          			test of the expected idle time is performed without the
   3362          			scheduler suspended.  The result here is not necessarily
   3363          			valid. */
   3364          			xExpectedIdleTime = prvGetExpectedIdleTime();
   3365          
   3366          			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
   3367          			{
   3368          				vTaskSuspendAll();
   3369          				{
   3370          					/* Now the scheduler is suspended, the expected idle
   3371          					time can be sampled again, and this time its value can
   3372          					be used. */
   3373          					configASSERT( xNextTaskUnblockTime >= xTickCount );
   3374          					xExpectedIdleTime = prvGetExpectedIdleTime();
   3375          
   3376          					/* Define the following macro to set xExpectedIdleTime to 0
   3377          					if the application does not want
   3378          					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
   3379          					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
   3380          
   3381          					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
   3382          					{
   3383          						traceLOW_POWER_IDLE_BEGIN();
   3384          						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
   3385          						traceLOW_POWER_IDLE_END();
   3386          					}
   3387          					else
   3388          					{
   3389          						mtCOVERAGE_TEST_MARKER();
   3390          					}
   3391          				}
   3392          				( void ) xTaskResumeAll();
   3393          			}
   3394          			else
   3395          			{
   3396          				mtCOVERAGE_TEST_MARKER();
   3397          			}
   3398          		}
   3399          		#endif /* configUSE_TICKLESS_IDLE */
   3400          	}
   3401          }
   3402          /*-----------------------------------------------------------*/
   3403          
   3404          #if( configUSE_TICKLESS_IDLE != 0 )
   3405          
   3406          	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
   3407          	{
   3408          	/* The idle task exists in addition to the application tasks. */
   3409          	const UBaseType_t uxNonApplicationTasks = 1;
   3410          	eSleepModeStatus eReturn = eStandardSleep;
   3411          
   3412          		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
   3413          		{
   3414          			/* A task was made ready while the scheduler was suspended. */
   3415          			eReturn = eAbortSleep;
   3416          		}
   3417          		else if( xYieldPending != pdFALSE )
   3418          		{
   3419          			/* A yield was pended while the scheduler was suspended. */
   3420          			eReturn = eAbortSleep;
   3421          		}
   3422          		else
   3423          		{
   3424          			/* If all the tasks are in the suspended list (which might mean they
   3425          			have an infinite block time rather than actually being suspended)
   3426          			then it is safe to turn all clocks off and just wait for external
   3427          			interrupts. */
   3428          			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
   3429          			{
   3430          				eReturn = eNoTasksWaitingTimeout;
   3431          			}
   3432          			else
   3433          			{
   3434          				mtCOVERAGE_TEST_MARKER();
   3435          			}
   3436          		}
   3437          
   3438          		return eReturn;
   3439          	}
   3440          
   3441          #endif /* configUSE_TICKLESS_IDLE */
   3442          /*-----------------------------------------------------------*/
   3443          
   3444          #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
   3445          
   3446          	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue )
   3447          	{
   3448          	TCB_t *pxTCB;
   3449          
   3450          		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
   3451          		{
   3452          			pxTCB = prvGetTCBFromHandle( xTaskToSet );
   3453          			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
   3454          		}
   3455          	}
   3456          
   3457          #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
   3458          /*-----------------------------------------------------------*/
   3459          
   3460          #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
   3461          
   3462          	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
   3463          	{
   3464          	void *pvReturn = NULL;
   3465          	TCB_t *pxTCB;
   3466          
   3467          		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
   3468          		{
   3469          			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
   3470          			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
   3471          		}
   3472          		else
   3473          		{
   3474          			pvReturn = NULL;
   3475          		}
   3476          
   3477          		return pvReturn;
   3478          	}
   3479          
   3480          #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
   3481          /*-----------------------------------------------------------*/
   3482          
   3483          #if ( portUSING_MPU_WRAPPERS == 1 )
   3484          
   3485          	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
   3486          	{
   3487          	TCB_t *pxTCB;
   3488          
   3489          		/* If null is passed in here then we are modifying the MPU settings of
   3490          		the calling task. */
   3491          		pxTCB = prvGetTCBFromHandle( xTaskToModify );
   3492          
   3493          		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
   3494          	}
   3495          
   3496          #endif /* portUSING_MPU_WRAPPERS */
   3497          /*-----------------------------------------------------------*/
   3498          
   3499          static void prvInitialiseTaskLists( void )
   3500          {
   3501          UBaseType_t uxPriority;
   3502          
   3503          	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   3504          	{
   3505          		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   3506          	}
   3507          
   3508          	vListInitialise( &xDelayedTaskList1 );
   3509          	vListInitialise( &xDelayedTaskList2 );
   3510          	vListInitialise( &xPendingReadyList );
   3511          
   3512          	#if ( INCLUDE_vTaskDelete == 1 )
   3513          	{
   3514          		vListInitialise( &xTasksWaitingTermination );
   3515          	}
   3516          	#endif /* INCLUDE_vTaskDelete */
   3517          
   3518          	#if ( INCLUDE_vTaskSuspend == 1 )
   3519          	{
   3520          		vListInitialise( &xSuspendedTaskList );
   3521          	}
   3522          	#endif /* INCLUDE_vTaskSuspend */
   3523          
   3524          	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
   3525          	using list2. */
   3526          	pxDelayedTaskList = &xDelayedTaskList1;
   3527          	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   3528          }
   3529          /*-----------------------------------------------------------*/
   3530          
   3531          static void prvCheckTasksWaitingTermination( void )
   3532          {
   3533          
   3534          	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
   3535          
   3536          	#if ( INCLUDE_vTaskDelete == 1 )
   3537          	{
   3538          		TCB_t *pxTCB;
   3539          
   3540          		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
   3541          		being called too often in the idle task. */
   3542          		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   3543          		{
   3544          			taskENTER_CRITICAL();
   3545          			{
   3546          				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   3547          				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   3548          				--uxCurrentNumberOfTasks;
   3549          				--uxDeletedTasksWaitingCleanUp;
   3550          			}
   3551          			taskEXIT_CRITICAL();
   3552          
   3553          			prvDeleteTCB( pxTCB );
   3554          		}
   3555          	}
   3556          	#endif /* INCLUDE_vTaskDelete */
   3557          }
   3558          /*-----------------------------------------------------------*/
   3559          
   3560          #if( configUSE_TRACE_FACILITY == 1 )
   3561          
   3562          	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
   3563          	{
   3564          	TCB_t *pxTCB;
   3565          
   3566          		/* xTask is NULL then get the state of the calling task. */
   3567          		pxTCB = prvGetTCBFromHandle( xTask );
   3568          
   3569          		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
   3570          		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
   3571          		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
   3572          		pxTaskStatus->pxStackBase = pxTCB->pxStack;
   3573          		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
   3574          
   3575          		#if ( configUSE_MUTEXES == 1 )
   3576          		{
   3577          			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
   3578          		}
   3579          		#else
   3580          		{
   3581          			pxTaskStatus->uxBasePriority = 0;
   3582          		}
   3583          		#endif
   3584          
   3585          		#if ( configGENERATE_RUN_TIME_STATS == 1 )
   3586          		{
   3587          			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
   3588          		}
   3589          		#else
   3590          		{
   3591          			pxTaskStatus->ulRunTimeCounter = 0;
   3592          		}
   3593          		#endif
   3594          
   3595          		/* Obtaining the task state is a little fiddly, so is only done if the
   3596          		value of eState passed into this function is eInvalid - otherwise the
   3597          		state is just set to whatever is passed in. */
   3598          		if( eState != eInvalid )
   3599          		{
   3600          			if( pxTCB == pxCurrentTCB )
   3601          			{
   3602          				pxTaskStatus->eCurrentState = eRunning;
   3603          			}
   3604          			else
   3605          			{
   3606          				pxTaskStatus->eCurrentState = eState;
   3607          
   3608          				#if ( INCLUDE_vTaskSuspend == 1 )
   3609          				{
   3610          					/* If the task is in the suspended list then there is a
   3611          					chance it is actually just blocked indefinitely - so really
   3612          					it should be reported as being in the Blocked state. */
   3613          					if( eState == eSuspended )
   3614          					{
   3615          						vTaskSuspendAll();
   3616          						{
   3617          							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   3618          							{
   3619          								pxTaskStatus->eCurrentState = eBlocked;
   3620          							}
   3621          						}
   3622          						( void ) xTaskResumeAll();
   3623          					}
   3624          				}
   3625          				#endif /* INCLUDE_vTaskSuspend */
   3626          			}
   3627          		}
   3628          		else
   3629          		{
   3630          			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
   3631          		}
   3632          
   3633          		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
   3634          		parameter is provided to allow it to be skipped. */
   3635          		if( xGetFreeStackSpace != pdFALSE )
   3636          		{
   3637          			#if ( portSTACK_GROWTH > 0 )
   3638          			{
   3639          				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
   3640          			}
   3641          			#else
   3642          			{
   3643          				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
   3644          			}
   3645          			#endif
   3646          		}
   3647          		else
   3648          		{
   3649          			pxTaskStatus->usStackHighWaterMark = 0;
   3650          		}
   3651          	}
   3652          
   3653          #endif /* configUSE_TRACE_FACILITY */
   3654          /*-----------------------------------------------------------*/
   3655          
   3656          #if ( configUSE_TRACE_FACILITY == 1 )
   3657          
   3658          	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
   3659          	{
   3660          	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
   3661          	UBaseType_t uxTask = 0;
   3662          
   3663          		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
   3664          		{
   3665          			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   3666          
   3667          			/* Populate an TaskStatus_t structure within the
   3668          			pxTaskStatusArray array for each task that is referenced from
   3669          			pxList.  See the definition of TaskStatus_t in task.h for the
   3670          			meaning of each TaskStatus_t structure member. */
   3671          			do
   3672          			{
   3673          				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   3674          				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
   3675          				uxTask++;
   3676          			} while( pxNextTCB != pxFirstTCB );
   3677          		}
   3678          		else
   3679          		{
   3680          			mtCOVERAGE_TEST_MARKER();
   3681          		}
   3682          
   3683          		return uxTask;
   3684          	}
   3685          
   3686          #endif /* configUSE_TRACE_FACILITY */
   3687          /*-----------------------------------------------------------*/
   3688          
   3689          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
   3690          
   3691          	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
   3692          	{
   3693          	uint32_t ulCount = 0U;
   3694          
   3695          		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
   3696          		{
   3697          			pucStackByte -= portSTACK_GROWTH;
   3698          			ulCount++;
   3699          		}
   3700          
   3701          		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
   3702          
   3703          		return ( configSTACK_DEPTH_TYPE ) ulCount;
   3704          	}
   3705          
   3706          #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
   3707          /*-----------------------------------------------------------*/
   3708          
   3709          #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
   3710          
   3711          	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
   3712          	{
   3713          	TCB_t *pxTCB;
   3714          	uint8_t *pucEndOfStack;
   3715          	UBaseType_t uxReturn;
   3716          
   3717          		pxTCB = prvGetTCBFromHandle( xTask );
   3718          
   3719          		#if portSTACK_GROWTH < 0
   3720          		{
   3721          			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
   3722          		}
   3723          		#else
   3724          		{
   3725          			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
   3726          		}
   3727          		#endif
   3728          
   3729          		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
   3730          
   3731          		return uxReturn;
   3732          	}
   3733          
   3734          #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
   3735          /*-----------------------------------------------------------*/
   3736          
   3737          #if ( INCLUDE_vTaskDelete == 1 )
   3738          
   3739          	static void prvDeleteTCB( TCB_t *pxTCB )
   3740          	{
   3741          		/* This call is required specifically for the TriCore port.  It must be
   3742          		above the vPortFree() calls.  The call is also used by ports/demos that
   3743          		want to allocate and clean RAM statically. */
   3744          		portCLEAN_UP_TCB( pxTCB );
   3745          
   3746          		/* Free up the memory allocated by the scheduler for the task.  It is up
   3747          		to the task to free any memory allocated at the application level. */
   3748          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   3749          		{
   3750          			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
   3751          		}
   3752          		#endif /* configUSE_NEWLIB_REENTRANT */
   3753          
   3754          		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
   3755          		{
   3756          			/* The task can only have been allocated dynamically - free both
   3757          			the stack and TCB. */
   3758          			vPortFree( pxTCB->pxStack );
   3759          			vPortFree( pxTCB );
   3760          		}
   3761          		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
   3762          		{
   3763          			/* The task could have been allocated statically or dynamically, so
   3764          			check what was statically allocated before trying to free the
   3765          			memory. */
   3766          			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
   3767          			{
   3768          				/* Both the stack and TCB were allocated dynamically, so both
   3769          				must be freed. */
   3770          				vPortFree( pxTCB->pxStack );
   3771          				vPortFree( pxTCB );
   3772          			}
   3773          			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
   3774          			{
   3775          				/* Only the stack was statically allocated, so the TCB is the
   3776          				only memory that must be freed. */
   3777          				vPortFree( pxTCB );
   3778          			}
   3779          			else
   3780          			{
   3781          				/* Neither the stack nor the TCB were allocated dynamically, so
   3782          				nothing needs to be freed. */
   3783          				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
   3784          				mtCOVERAGE_TEST_MARKER();
   3785          			}
   3786          		}
   3787          		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
   3788          	}
   3789          
   3790          #endif /* INCLUDE_vTaskDelete */
   3791          /*-----------------------------------------------------------*/
   3792          
   3793          static void prvResetNextTaskUnblockTime( void )
   3794          {
   3795          TCB_t *pxTCB;
   3796          
   3797          	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   3798          	{
   3799          		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
   3800          		the maximum possible value so it is	extremely unlikely that the
   3801          		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
   3802          		there is an item in the delayed list. */
   3803          		xNextTaskUnblockTime = portMAX_DELAY;
   3804          	}
   3805          	else
   3806          	{
   3807          		/* The new current delayed list is not empty, get the value of
   3808          		the item at the head of the delayed list.  This is the time at
   3809          		which the task at the head of the delayed list should be removed
   3810          		from the Blocked state. */
   3811          		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   3812          		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
   3813          	}
   3814          }
   3815          /*-----------------------------------------------------------*/
   3816          
   3817          #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
   3818          
   3819          	TaskHandle_t xTaskGetCurrentTaskHandle( void )
   3820          	{
   3821          	TaskHandle_t xReturn;
   3822          
   3823          		/* A critical section is not required as this is not called from
   3824          		an interrupt and the current TCB will always be the same for any
   3825          		individual execution thread. */
   3826          		xReturn = pxCurrentTCB;
   3827          
   3828          		return xReturn;
   3829          	}
   3830          
   3831          #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
   3832          /*-----------------------------------------------------------*/
   3833          
   3834          #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
   3835          
   3836          	BaseType_t xTaskGetSchedulerState( void )
   3837          	{
   3838          	BaseType_t xReturn;
   3839          
   3840          		if( xSchedulerRunning == pdFALSE )
   3841          		{
   3842          			xReturn = taskSCHEDULER_NOT_STARTED;
   3843          		}
   3844          		else
   3845          		{
   3846          			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   3847          			{
   3848          				xReturn = taskSCHEDULER_RUNNING;
   3849          			}
   3850          			else
   3851          			{
   3852          				xReturn = taskSCHEDULER_SUSPENDED;
   3853          			}
   3854          		}
   3855          
   3856          		return xReturn;
   3857          	}
   3858          
   3859          #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
   3860          /*-----------------------------------------------------------*/
   3861          
   3862          #if ( configUSE_MUTEXES == 1 )
   3863          
   3864          	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
   3865          	{
   3866          	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
   3867          	BaseType_t xReturn = pdFALSE;
   3868          
   3869          		/* If the mutex was given back by an interrupt while the queue was
   3870          		locked then the mutex holder might now be NULL.  _RB_ Is this still
   3871          		needed as interrupts can no longer use mutexes? */
   3872          		if( pxMutexHolder != NULL )
   3873          		{
   3874          			/* If the holder of the mutex has a priority below the priority of
   3875          			the task attempting to obtain the mutex then it will temporarily
   3876          			inherit the priority of the task attempting to obtain the mutex. */
   3877          			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
   3878          			{
   3879          				/* Adjust the mutex holder state to account for its new
   3880          				priority.  Only reset the event list item value if the value is
   3881          				not being used for anything else. */
   3882          				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   3883          				{
   3884          					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3885          				}
   3886          				else
   3887          				{
   3888          					mtCOVERAGE_TEST_MARKER();
   3889          				}
   3890          
   3891          				/* If the task being modified is in the ready state it will need
   3892          				to be moved into a new list. */
   3893          				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
   3894          				{
   3895          					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   3896          					{
   3897          						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
   3898          					}
   3899          					else
   3900          					{
   3901          						mtCOVERAGE_TEST_MARKER();
   3902          					}
   3903          
   3904          					/* Inherit the priority before being moved into the new list. */
   3905          					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   3906          					prvAddTaskToReadyList( pxMutexHolderTCB );
   3907          				}
   3908          				else
   3909          				{
   3910          					/* Just inherit the priority. */
   3911          					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   3912          				}
   3913          
   3914          				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
   3915          
   3916          				/* Inheritance occurred. */
   3917          				xReturn = pdTRUE;
   3918          			}
   3919          			else
   3920          			{
   3921          				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
   3922          				{
   3923          					/* The base priority of the mutex holder is lower than the
   3924          					priority of the task attempting to take the mutex, but the
   3925          					current priority of the mutex holder is not lower than the
   3926          					priority of the task attempting to take the mutex.
   3927          					Therefore the mutex holder must have already inherited a
   3928          					priority, but inheritance would have occurred if that had
   3929          					not been the case. */
   3930          					xReturn = pdTRUE;
   3931          				}
   3932          				else
   3933          				{
   3934          					mtCOVERAGE_TEST_MARKER();
   3935          				}
   3936          			}
   3937          		}
   3938          		else
   3939          		{
   3940          			mtCOVERAGE_TEST_MARKER();
   3941          		}
   3942          
   3943          		return xReturn;
   3944          	}
   3945          
   3946          #endif /* configUSE_MUTEXES */
   3947          /*-----------------------------------------------------------*/
   3948          
   3949          #if ( configUSE_MUTEXES == 1 )
   3950          
   3951          	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
   3952          	{
   3953          	TCB_t * const pxTCB = pxMutexHolder;
   3954          	BaseType_t xReturn = pdFALSE;
   3955          
   3956          		if( pxMutexHolder != NULL )
   3957          		{
   3958          			/* A task can only have an inherited priority if it holds the mutex.
   3959          			If the mutex is held by a task then it cannot be given from an
   3960          			interrupt, and if a mutex is given by the holding task then it must
   3961          			be the running state task. */
   3962          			configASSERT( pxTCB == pxCurrentTCB );
   3963          			configASSERT( pxTCB->uxMutexesHeld );
   3964          			( pxTCB->uxMutexesHeld )--;
   3965          
   3966          			/* Has the holder of the mutex inherited the priority of another
   3967          			task? */
   3968          			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   3969          			{
   3970          				/* Only disinherit if no other mutexes are held. */
   3971          				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
   3972          				{
   3973          					/* A task can only have an inherited priority if it holds
   3974          					the mutex.  If the mutex is held by a task then it cannot be
   3975          					given from an interrupt, and if a mutex is given by the
   3976          					holding task then it must be the running state task.  Remove
   3977          					the holding task from the ready list. */
   3978          					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   3979          					{
   3980          						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   3981          					}
   3982          					else
   3983          					{
   3984          						mtCOVERAGE_TEST_MARKER();
   3985          					}
   3986          
   3987          					/* Disinherit the priority before adding the task into the
   3988          					new	ready list. */
   3989          					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
   3990          					pxTCB->uxPriority = pxTCB->uxBasePriority;
   3991          
   3992          					/* Reset the event list item value.  It cannot be in use for
   3993          					any other purpose if this task is running, and it must be
   3994          					running to give back the mutex. */
   3995          					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3996          					prvAddTaskToReadyList( pxTCB );
   3997          
   3998          					/* Return true to indicate that a context switch is required.
   3999          					This is only actually required in the corner case whereby
   4000          					multiple mutexes were held and the mutexes were given back
   4001          					in an order different to that in which they were taken.
   4002          					If a context switch did not occur when the first mutex was
   4003          					returned, even if a task was waiting on it, then a context
   4004          					switch should occur when the last mutex is returned whether
   4005          					a task is waiting on it or not. */
   4006          					xReturn = pdTRUE;
   4007          				}
   4008          				else
   4009          				{
   4010          					mtCOVERAGE_TEST_MARKER();
   4011          				}
   4012          			}
   4013          			else
   4014          			{
   4015          				mtCOVERAGE_TEST_MARKER();
   4016          			}
   4017          		}
   4018          		else
   4019          		{
   4020          			mtCOVERAGE_TEST_MARKER();
   4021          		}
   4022          
   4023          		return xReturn;
   4024          	}
   4025          
   4026          #endif /* configUSE_MUTEXES */
   4027          /*-----------------------------------------------------------*/
   4028          
   4029          #if ( configUSE_MUTEXES == 1 )
   4030          
   4031          	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
   4032          	{
   4033          	TCB_t * const pxTCB = pxMutexHolder;
   4034          	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
   4035          	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
   4036          
   4037          		if( pxMutexHolder != NULL )
   4038          		{
   4039          			/* If pxMutexHolder is not NULL then the holder must hold at least
   4040          			one mutex. */
   4041          			configASSERT( pxTCB->uxMutexesHeld );
   4042          
   4043          			/* Determine the priority to which the priority of the task that
   4044          			holds the mutex should be set.  This will be the greater of the
   4045          			holding task's base priority and the priority of the highest
   4046          			priority task that is waiting to obtain the mutex. */
   4047          			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
   4048          			{
   4049          				uxPriorityToUse = uxHighestPriorityWaitingTask;
   4050          			}
   4051          			else
   4052          			{
   4053          				uxPriorityToUse = pxTCB->uxBasePriority;
   4054          			}
   4055          
   4056          			/* Does the priority need to change? */
   4057          			if( pxTCB->uxPriority != uxPriorityToUse )
   4058          			{
   4059          				/* Only disinherit if no other mutexes are held.  This is a
   4060          				simplification in the priority inheritance implementation.  If
   4061          				the task that holds the mutex is also holding other mutexes then
   4062          				the other mutexes may have caused the priority inheritance. */
   4063          				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
   4064          				{
   4065          					/* If a task has timed out because it already holds the
   4066          					mutex it was trying to obtain then it cannot of inherited
   4067          					its own priority. */
   4068          					configASSERT( pxTCB != pxCurrentTCB );
   4069          
   4070          					/* Disinherit the priority, remembering the previous
   4071          					priority to facilitate determining the subject task's
   4072          					state. */
   4073          					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
   4074          					uxPriorityUsedOnEntry = pxTCB->uxPriority;
   4075          					pxTCB->uxPriority = uxPriorityToUse;
   4076          
   4077          					/* Only reset the event list item value if the value is not
   4078          					being used for anything else. */
   4079          					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   4080          					{
   4081          						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   4082          					}
   4083          					else
   4084          					{
   4085          						mtCOVERAGE_TEST_MARKER();
   4086          					}
   4087          
   4088          					/* If the running task is not the task that holds the mutex
   4089          					then the task that holds the mutex could be in either the
   4090          					Ready, Blocked or Suspended states.  Only remove the task
   4091          					from its current state list if it is in the Ready state as
   4092          					the task's priority is going to change and there is one
   4093          					Ready list per priority. */
   4094          					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
   4095          					{
   4096          						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   4097          						{
   4098          							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   4099          						}
   4100          						else
   4101          						{
   4102          							mtCOVERAGE_TEST_MARKER();
   4103          						}
   4104          
   4105          						prvAddTaskToReadyList( pxTCB );
   4106          					}
   4107          					else
   4108          					{
   4109          						mtCOVERAGE_TEST_MARKER();
   4110          					}
   4111          				}
   4112          				else
   4113          				{
   4114          					mtCOVERAGE_TEST_MARKER();
   4115          				}
   4116          			}
   4117          			else
   4118          			{
   4119          				mtCOVERAGE_TEST_MARKER();
   4120          			}
   4121          		}
   4122          		else
   4123          		{
   4124          			mtCOVERAGE_TEST_MARKER();
   4125          		}
   4126          	}
   4127          
   4128          #endif /* configUSE_MUTEXES */
   4129          /*-----------------------------------------------------------*/
   4130          
   4131          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   4132          
   4133          	void vTaskEnterCritical( void )
   4134          	{
   4135          		portDISABLE_INTERRUPTS();
   4136          
   4137          		if( xSchedulerRunning != pdFALSE )
   4138          		{
   4139          			( pxCurrentTCB->uxCriticalNesting )++;
   4140          
   4141          			/* This is not the interrupt safe version of the enter critical
   4142          			function so	assert() if it is being called from an interrupt
   4143          			context.  Only API functions that end in "FromISR" can be used in an
   4144          			interrupt.  Only assert if the critical nesting count is 1 to
   4145          			protect against recursive calls if the assert function also uses a
   4146          			critical section. */
   4147          			if( pxCurrentTCB->uxCriticalNesting == 1 )
   4148          			{
   4149          				portASSERT_IF_IN_ISR();
   4150          			}
   4151          		}
   4152          		else
   4153          		{
   4154          			mtCOVERAGE_TEST_MARKER();
   4155          		}
   4156          	}
   4157          
   4158          #endif /* portCRITICAL_NESTING_IN_TCB */
   4159          /*-----------------------------------------------------------*/
   4160          
   4161          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   4162          
   4163          	void vTaskExitCritical( void )
   4164          	{
   4165          		if( xSchedulerRunning != pdFALSE )
   4166          		{
   4167          			if( pxCurrentTCB->uxCriticalNesting > 0U )
   4168          			{
   4169          				( pxCurrentTCB->uxCriticalNesting )--;
   4170          
   4171          				if( pxCurrentTCB->uxCriticalNesting == 0U )
   4172          				{
   4173          					portENABLE_INTERRUPTS();
   4174          				}
   4175          				else
   4176          				{
   4177          					mtCOVERAGE_TEST_MARKER();
   4178          				}
   4179          			}
   4180          			else
   4181          			{
   4182          				mtCOVERAGE_TEST_MARKER();
   4183          			}
   4184          		}
   4185          		else
   4186          		{
   4187          			mtCOVERAGE_TEST_MARKER();
   4188          		}
   4189          	}
   4190          
   4191          #endif /* portCRITICAL_NESTING_IN_TCB */
   4192          /*-----------------------------------------------------------*/
   4193          
   4194          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
   4195          
   4196          	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
   4197          	{
   4198          	size_t x;
   4199          
   4200          		/* Start by copying the entire string. */
   4201          		strcpy( pcBuffer, pcTaskName );
   4202          
   4203          		/* Pad the end of the string with spaces to ensure columns line up when
   4204          		printed out. */
   4205          		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
   4206          		{
   4207          			pcBuffer[ x ] = ' ';
   4208          		}
   4209          
   4210          		/* Terminate. */
   4211          		pcBuffer[ x ] = ( char ) 0x00;
   4212          
   4213          		/* Return the new end of string. */
   4214          		return &( pcBuffer[ x ] );
   4215          	}
   4216          
   4217          #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
   4218          /*-----------------------------------------------------------*/
   4219          
   4220          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
   4221          
   4222          	void vTaskList( char * pcWriteBuffer )
   4223          	{
   4224          	TaskStatus_t *pxTaskStatusArray;
   4225          	UBaseType_t uxArraySize, x;
   4226          	char cStatus;
   4227          
   4228          		/*
   4229          		 * PLEASE NOTE:
   4230          		 *
   4231          		 * This function is provided for convenience only, and is used by many
   4232          		 * of the demo applications.  Do not consider it to be part of the
   4233          		 * scheduler.
   4234          		 *
   4235          		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
   4236          		 * uxTaskGetSystemState() output into a human readable table that
   4237          		 * displays task names, states and stack usage.
   4238          		 *
   4239          		 * vTaskList() has a dependency on the sprintf() C library function that
   4240          		 * might bloat the code size, use a lot of stack, and provide different
   4241          		 * results on different platforms.  An alternative, tiny, third party,
   4242          		 * and limited functionality implementation of sprintf() is provided in
   4243          		 * many of the FreeRTOS/Demo sub-directories in a file called
   4244          		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
   4245          		 * snprintf() implementation!).
   4246          		 *
   4247          		 * It is recommended that production systems call uxTaskGetSystemState()
   4248          		 * directly to get access to raw stats data, rather than indirectly
   4249          		 * through a call to vTaskList().
   4250          		 */
   4251          
   4252          
   4253          		/* Make sure the write buffer does not contain a string. */
   4254          		*pcWriteBuffer = ( char ) 0x00;
   4255          
   4256          		/* Take a snapshot of the number of tasks in case it changes while this
   4257          		function is executing. */
   4258          		uxArraySize = uxCurrentNumberOfTasks;
   4259          
   4260          		/* Allocate an array index for each task.  NOTE!  if
   4261          		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
   4262          		equate to NULL. */
   4263          		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */
   4264          
   4265          		if( pxTaskStatusArray != NULL )
   4266          		{
   4267          			/* Generate the (binary) data. */
   4268          			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
   4269          
   4270          			/* Create a human readable table from the binary data. */
   4271          			for( x = 0; x < uxArraySize; x++ )
   4272          			{
   4273          				switch( pxTaskStatusArray[ x ].eCurrentState )
   4274          				{
   4275          					case eRunning:		cStatus = tskRUNNING_CHAR;
   4276          										break;
   4277          
   4278          					case eReady:		cStatus = tskREADY_CHAR;
   4279          										break;
   4280          
   4281          					case eBlocked:		cStatus = tskBLOCKED_CHAR;
   4282          										break;
   4283          
   4284          					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
   4285          										break;
   4286          
   4287          					case eDeleted:		cStatus = tskDELETED_CHAR;
   4288          										break;
   4289          
   4290          					case eInvalid:		/* Fall through. */
   4291          					default:			/* Should not get here, but it is included
   4292          										to prevent static checking errors. */
   4293          										cStatus = ( char ) 0x00;
   4294          										break;
   4295          				}
   4296          
   4297          				/* Write the task name to the string, padding with spaces so it
   4298          				can be printed in tabular form more easily. */
   4299          				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
   4300          
   4301          				/* Write the rest of the string. */
   4302          				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
   4303          				pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
   4304          			}
   4305          
   4306          			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
   4307          			is 0 then vPortFree() will be #defined to nothing. */
   4308          			vPortFree( pxTaskStatusArray );
   4309          		}
   4310          		else
   4311          		{
   4312          			mtCOVERAGE_TEST_MARKER();
   4313          		}
   4314          	}
   4315          
   4316          #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
   4317          /*----------------------------------------------------------*/
   4318          
   4319          #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
   4320          
   4321          	void vTaskGetRunTimeStats( char *pcWriteBuffer )
   4322          	{
   4323          	TaskStatus_t *pxTaskStatusArray;
   4324          	UBaseType_t uxArraySize, x;
   4325          	uint32_t ulTotalTime, ulStatsAsPercentage;
   4326          
   4327          		#if( configUSE_TRACE_FACILITY != 1 )
   4328          		{
   4329          			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
   4330          		}
   4331          		#endif
   4332          
   4333          		/*
   4334          		 * PLEASE NOTE:
   4335          		 *
   4336          		 * This function is provided for convenience only, and is used by many
   4337          		 * of the demo applications.  Do not consider it to be part of the
   4338          		 * scheduler.
   4339          		 *
   4340          		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
   4341          		 * of the uxTaskGetSystemState() output into a human readable table that
   4342          		 * displays the amount of time each task has spent in the Running state
   4343          		 * in both absolute and percentage terms.
   4344          		 *
   4345          		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
   4346          		 * function that might bloat the code size, use a lot of stack, and
   4347          		 * provide different results on different platforms.  An alternative,
   4348          		 * tiny, third party, and limited functionality implementation of
   4349          		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
   4350          		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
   4351          		 * a full snprintf() implementation!).
   4352          		 *
   4353          		 * It is recommended that production systems call uxTaskGetSystemState()
   4354          		 * directly to get access to raw stats data, rather than indirectly
   4355          		 * through a call to vTaskGetRunTimeStats().
   4356          		 */
   4357          
   4358          		/* Make sure the write buffer does not contain a string. */
   4359          		*pcWriteBuffer = ( char ) 0x00;
   4360          
   4361          		/* Take a snapshot of the number of tasks in case it changes while this
   4362          		function is executing. */
   4363          		uxArraySize = uxCurrentNumberOfTasks;
   4364          
   4365          		/* Allocate an array index for each task.  NOTE!  If
   4366          		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
   4367          		equate to NULL. */
   4368          		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */
   4369          
   4370          		if( pxTaskStatusArray != NULL )
   4371          		{
   4372          			/* Generate the (binary) data. */
   4373          			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
   4374          
   4375          			/* For percentage calculations. */
   4376          			ulTotalTime /= 100UL;
   4377          
   4378          			/* Avoid divide by zero errors. */
   4379          			if( ulTotalTime > 0UL )
   4380          			{
   4381          				/* Create a human readable table from the binary data. */
   4382          				for( x = 0; x < uxArraySize; x++ )
   4383          				{
   4384          					/* What percentage of the total run time has the task used?
   4385          					This will always be rounded down to the nearest integer.
   4386          					ulTotalRunTimeDiv100 has already been divided by 100. */
   4387          					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
   4388          
   4389          					/* Write the task name to the string, padding with
   4390          					spaces so it can be printed in tabular form more
   4391          					easily. */
   4392          					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
   4393          
   4394          					if( ulStatsAsPercentage > 0UL )
   4395          					{
   4396          						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
   4397          						{
   4398          							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
   4399          						}
   4400          						#else
   4401          						{
   4402          							/* sizeof( int ) == sizeof( long ) so a smaller
   4403          							printf() library can be used. */
   4404          							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
   4405          						}
   4406          						#endif
   4407          					}
   4408          					else
   4409          					{
   4410          						/* If the percentage is zero here then the task has
   4411          						consumed less than 1% of the total run time. */
   4412          						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
   4413          						{
   4414          							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
   4415          						}
   4416          						#else
   4417          						{
   4418          							/* sizeof( int ) == sizeof( long ) so a smaller
   4419          							printf() library can be used. */
   4420          							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
   4421          						}
   4422          						#endif
   4423          					}
   4424          
   4425          					pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
   4426          				}
   4427          			}
   4428          			else
   4429          			{
   4430          				mtCOVERAGE_TEST_MARKER();
   4431          			}
   4432          
   4433          			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
   4434          			is 0 then vPortFree() will be #defined to nothing. */
   4435          			vPortFree( pxTaskStatusArray );
   4436          		}
   4437          		else
   4438          		{
   4439          			mtCOVERAGE_TEST_MARKER();
   4440          		}
   4441          	}
   4442          
   4443          #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
   4444          /*-----------------------------------------------------------*/
   4445          
   4446          TickType_t uxTaskResetEventItemValue( void )
   4447          {
   4448          TickType_t uxReturn;
   4449          
   4450          	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
   4451          
   4452          	/* Reset the event list item to its normal value - so it can be used with
   4453          	queues and semaphores. */
   4454          	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   4455          
   4456          	return uxReturn;
   4457          }
   4458          /*-----------------------------------------------------------*/
   4459          
   4460          #if ( configUSE_MUTEXES == 1 )
   4461          
   4462          	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
   4463          	{
   4464          		/* If xSemaphoreCreateMutex() is called before any tasks have been created
   4465          		then pxCurrentTCB will be NULL. */
   4466          		if( pxCurrentTCB != NULL )
   4467          		{
   4468          			( pxCurrentTCB->uxMutexesHeld )++;
   4469          		}
   4470          
   4471          		return pxCurrentTCB;
   4472          	}
   4473          
   4474          #endif /* configUSE_MUTEXES */
   4475          /*-----------------------------------------------------------*/
   4476          
   4477          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4478          
   4479          	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
   4480          	{
   4481          	uint32_t ulReturn;
   4482          
   4483          		taskENTER_CRITICAL();
   4484          		{
   4485          			/* Only block if the notification count is not already non-zero. */
   4486          			if( pxCurrentTCB->ulNotifiedValue == 0UL )
   4487          			{
   4488          				/* Mark this task as waiting for a notification. */
   4489          				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
   4490          
   4491          				if( xTicksToWait > ( TickType_t ) 0 )
   4492          				{
   4493          					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   4494          					traceTASK_NOTIFY_TAKE_BLOCK();
   4495          
   4496          					/* All ports are written to allow a yield in a critical
   4497          					section (some will yield immediately, others wait until the
   4498          					critical section exits) - but it is not something that
   4499          					application code should ever do. */
   4500          					portYIELD_WITHIN_API();
   4501          				}
   4502          				else
   4503          				{
   4504          					mtCOVERAGE_TEST_MARKER();
   4505          				}
   4506          			}
   4507          			else
   4508          			{
   4509          				mtCOVERAGE_TEST_MARKER();
   4510          			}
   4511          		}
   4512          		taskEXIT_CRITICAL();
   4513          
   4514          		taskENTER_CRITICAL();
   4515          		{
   4516          			traceTASK_NOTIFY_TAKE();
   4517          			ulReturn = pxCurrentTCB->ulNotifiedValue;
   4518          
   4519          			if( ulReturn != 0UL )
   4520          			{
   4521          				if( xClearCountOnExit != pdFALSE )
   4522          				{
   4523          					pxCurrentTCB->ulNotifiedValue = 0UL;
   4524          				}
   4525          				else
   4526          				{
   4527          					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
   4528          				}
   4529          			}
   4530          			else
   4531          			{
   4532          				mtCOVERAGE_TEST_MARKER();
   4533          			}
   4534          
   4535          			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   4536          		}
   4537          		taskEXIT_CRITICAL();
   4538          
   4539          		return ulReturn;
   4540          	}
   4541          
   4542          #endif /* configUSE_TASK_NOTIFICATIONS */
   4543          /*-----------------------------------------------------------*/
   4544          
   4545          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4546          
   4547          	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
   4548          	{
   4549          	BaseType_t xReturn;
   4550          
   4551          		taskENTER_CRITICAL();
   4552          		{
   4553          			/* Only block if a notification is not already pending. */
   4554          			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
   4555          			{
   4556          				/* Clear bits in the task's notification value as bits may get
   4557          				set	by the notifying task or interrupt.  This can be used to
   4558          				clear the value to zero. */
   4559          				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
   4560          
   4561          				/* Mark this task as waiting for a notification. */
   4562          				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
   4563          
   4564          				if( xTicksToWait > ( TickType_t ) 0 )
   4565          				{
   4566          					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   4567          					traceTASK_NOTIFY_WAIT_BLOCK();
   4568          
   4569          					/* All ports are written to allow a yield in a critical
   4570          					section (some will yield immediately, others wait until the
   4571          					critical section exits) - but it is not something that
   4572          					application code should ever do. */
   4573          					portYIELD_WITHIN_API();
   4574          				}
   4575          				else
   4576          				{
   4577          					mtCOVERAGE_TEST_MARKER();
   4578          				}
   4579          			}
   4580          			else
   4581          			{
   4582          				mtCOVERAGE_TEST_MARKER();
   4583          			}
   4584          		}
   4585          		taskEXIT_CRITICAL();
   4586          
   4587          		taskENTER_CRITICAL();
   4588          		{
   4589          			traceTASK_NOTIFY_WAIT();
   4590          
   4591          			if( pulNotificationValue != NULL )
   4592          			{
   4593          				/* Output the current notification value, which may or may not
   4594          				have changed. */
   4595          				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
   4596          			}
   4597          
   4598          			/* If ucNotifyValue is set then either the task never entered the
   4599          			blocked state (because a notification was already pending) or the
   4600          			task unblocked because of a notification.  Otherwise the task
   4601          			unblocked because of a timeout. */
   4602          			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
   4603          			{
   4604          				/* A notification was not received. */
   4605          				xReturn = pdFALSE;
   4606          			}
   4607          			else
   4608          			{
   4609          				/* A notification was already pending or a notification was
   4610          				received while the task was waiting. */
   4611          				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
   4612          				xReturn = pdTRUE;
   4613          			}
   4614          
   4615          			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   4616          		}
   4617          		taskEXIT_CRITICAL();
   4618          
   4619          		return xReturn;
   4620          	}
   4621          
   4622          #endif /* configUSE_TASK_NOTIFICATIONS */
   4623          /*-----------------------------------------------------------*/
   4624          
   4625          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4626          
   4627          	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
   4628          	{
   4629          	TCB_t * pxTCB;
   4630          	BaseType_t xReturn = pdPASS;
   4631          	uint8_t ucOriginalNotifyState;
   4632          
   4633          		configASSERT( xTaskToNotify );
   4634          		pxTCB = xTaskToNotify;
   4635          
   4636          		taskENTER_CRITICAL();
   4637          		{
   4638          			if( pulPreviousNotificationValue != NULL )
   4639          			{
   4640          				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
   4641          			}
   4642          
   4643          			ucOriginalNotifyState = pxTCB->ucNotifyState;
   4644          
   4645          			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
   4646          
   4647          			switch( eAction )
   4648          			{
   4649          				case eSetBits	:
   4650          					pxTCB->ulNotifiedValue |= ulValue;
   4651          					break;
   4652          
   4653          				case eIncrement	:
   4654          					( pxTCB->ulNotifiedValue )++;
   4655          					break;
   4656          
   4657          				case eSetValueWithOverwrite	:
   4658          					pxTCB->ulNotifiedValue = ulValue;
   4659          					break;
   4660          
   4661          				case eSetValueWithoutOverwrite :
   4662          					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
   4663          					{
   4664          						pxTCB->ulNotifiedValue = ulValue;
   4665          					}
   4666          					else
   4667          					{
   4668          						/* The value could not be written to the task. */
   4669          						xReturn = pdFAIL;
   4670          					}
   4671          					break;
   4672          
   4673          				case eNoAction:
   4674          					/* The task is being notified without its notify value being
   4675          					updated. */
   4676          					break;
   4677          
   4678          				default:
   4679          					/* Should not get here if all enums are handled.
   4680          					Artificially force an assert by testing a value the
   4681          					compiler can't assume is const. */
   4682          					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
   4683          
   4684          					break;
   4685          			}
   4686          
   4687          			traceTASK_NOTIFY();
   4688          
   4689          			/* If the task is in the blocked state specifically to wait for a
   4690          			notification then unblock it now. */
   4691          			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   4692          			{
   4693          				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   4694          				prvAddTaskToReadyList( pxTCB );
   4695          
   4696          				/* The task should not have been on an event list. */
   4697          				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   4698          
   4699          				#if( configUSE_TICKLESS_IDLE != 0 )
   4700          				{
   4701          					/* If a task is blocked waiting for a notification then
   4702          					xNextTaskUnblockTime might be set to the blocked task's time
   4703          					out time.  If the task is unblocked for a reason other than
   4704          					a timeout xNextTaskUnblockTime is normally left unchanged,
   4705          					because it will automatically get reset to a new value when
   4706          					the tick count equals xNextTaskUnblockTime.  However if
   4707          					tickless idling is used it might be more important to enter
   4708          					sleep mode at the earliest possible time - so reset
   4709          					xNextTaskUnblockTime here to ensure it is updated at the
   4710          					earliest possible time. */
   4711          					prvResetNextTaskUnblockTime();
   4712          				}
   4713          				#endif
   4714          
   4715          				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   4716          				{
   4717          					/* The notified task has a priority above the currently
   4718          					executing task so a yield is required. */
   4719          					taskYIELD_IF_USING_PREEMPTION();
   4720          				}
   4721          				else
   4722          				{
   4723          					mtCOVERAGE_TEST_MARKER();
   4724          				}
   4725          			}
   4726          			else
   4727          			{
   4728          				mtCOVERAGE_TEST_MARKER();
   4729          			}
   4730          		}
   4731          		taskEXIT_CRITICAL();
   4732          
   4733          		return xReturn;
   4734          	}
   4735          
   4736          #endif /* configUSE_TASK_NOTIFICATIONS */
   4737          /*-----------------------------------------------------------*/
   4738          
   4739          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4740          
   4741          	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
   4742          	{
   4743          	TCB_t * pxTCB;
   4744          	uint8_t ucOriginalNotifyState;
   4745          	BaseType_t xReturn = pdPASS;
   4746          	UBaseType_t uxSavedInterruptStatus;
   4747          
   4748          		configASSERT( xTaskToNotify );
   4749          
   4750          		/* RTOS ports that support interrupt nesting have the concept of a
   4751          		maximum	system call (or maximum API call) interrupt priority.
   4752          		Interrupts that are	above the maximum system call priority are keep
   4753          		permanently enabled, even when the RTOS kernel is in a critical section,
   4754          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   4755          		is defined in FreeRTOSConfig.h then
   4756          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   4757          		failure if a FreeRTOS API function is called from an interrupt that has
   4758          		been assigned a priority above the configured maximum system call
   4759          		priority.  Only FreeRTOS functions that end in FromISR can be called
   4760          		from interrupts	that have been assigned a priority at or (logically)
   4761          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   4762          		separate interrupt safe API to ensure interrupt entry is as fast and as
   4763          		simple as possible.  More information (albeit Cortex-M specific) is
   4764          		provided on the following link:
   4765          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   4766          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   4767          
   4768          		pxTCB = xTaskToNotify;
   4769          
   4770          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   4771          		{
   4772          			if( pulPreviousNotificationValue != NULL )
   4773          			{
   4774          				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
   4775          			}
   4776          
   4777          			ucOriginalNotifyState = pxTCB->ucNotifyState;
   4778          			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
   4779          
   4780          			switch( eAction )
   4781          			{
   4782          				case eSetBits	:
   4783          					pxTCB->ulNotifiedValue |= ulValue;
   4784          					break;
   4785          
   4786          				case eIncrement	:
   4787          					( pxTCB->ulNotifiedValue )++;
   4788          					break;
   4789          
   4790          				case eSetValueWithOverwrite	:
   4791          					pxTCB->ulNotifiedValue = ulValue;
   4792          					break;
   4793          
   4794          				case eSetValueWithoutOverwrite :
   4795          					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
   4796          					{
   4797          						pxTCB->ulNotifiedValue = ulValue;
   4798          					}
   4799          					else
   4800          					{
   4801          						/* The value could not be written to the task. */
   4802          						xReturn = pdFAIL;
   4803          					}
   4804          					break;
   4805          
   4806          				case eNoAction :
   4807          					/* The task is being notified without its notify value being
   4808          					updated. */
   4809          					break;
   4810          
   4811          				default:
   4812          					/* Should not get here if all enums are handled.
   4813          					Artificially force an assert by testing a value the
   4814          					compiler can't assume is const. */
   4815          					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
   4816          					break;
   4817          			}
   4818          
   4819          			traceTASK_NOTIFY_FROM_ISR();
   4820          
   4821          			/* If the task is in the blocked state specifically to wait for a
   4822          			notification then unblock it now. */
   4823          			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   4824          			{
   4825          				/* The task should not have been on an event list. */
   4826          				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   4827          
   4828          				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   4829          				{
   4830          					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   4831          					prvAddTaskToReadyList( pxTCB );
   4832          				}
   4833          				else
   4834          				{
   4835          					/* The delayed and ready lists cannot be accessed, so hold
   4836          					this task pending until the scheduler is resumed. */
   4837          					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   4838          				}
   4839          
   4840          				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   4841          				{
   4842          					/* The notified task has a priority above the currently
   4843          					executing task so a yield is required. */
   4844          					if( pxHigherPriorityTaskWoken != NULL )
   4845          					{
   4846          						*pxHigherPriorityTaskWoken = pdTRUE;
   4847          					}
   4848          
   4849          					/* Mark that a yield is pending in case the user is not
   4850          					using the "xHigherPriorityTaskWoken" parameter to an ISR
   4851          					safe FreeRTOS function. */
   4852          					xYieldPending = pdTRUE;
   4853          				}
   4854          				else
   4855          				{
   4856          					mtCOVERAGE_TEST_MARKER();
   4857          				}
   4858          			}
   4859          		}
   4860          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   4861          
   4862          		return xReturn;
   4863          	}
   4864          
   4865          #endif /* configUSE_TASK_NOTIFICATIONS */
   4866          /*-----------------------------------------------------------*/
   4867          
   4868          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4869          
   4870          	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
   4871          	{
   4872          	TCB_t * pxTCB;
   4873          	uint8_t ucOriginalNotifyState;
   4874          	UBaseType_t uxSavedInterruptStatus;
   4875          
   4876          		configASSERT( xTaskToNotify );
   4877          
   4878          		/* RTOS ports that support interrupt nesting have the concept of a
   4879          		maximum	system call (or maximum API call) interrupt priority.
   4880          		Interrupts that are	above the maximum system call priority are keep
   4881          		permanently enabled, even when the RTOS kernel is in a critical section,
   4882          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   4883          		is defined in FreeRTOSConfig.h then
   4884          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   4885          		failure if a FreeRTOS API function is called from an interrupt that has
   4886          		been assigned a priority above the configured maximum system call
   4887          		priority.  Only FreeRTOS functions that end in FromISR can be called
   4888          		from interrupts	that have been assigned a priority at or (logically)
   4889          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   4890          		separate interrupt safe API to ensure interrupt entry is as fast and as
   4891          		simple as possible.  More information (albeit Cortex-M specific) is
   4892          		provided on the following link:
   4893          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   4894          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   4895          
   4896          		pxTCB = xTaskToNotify;
   4897          
   4898          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   4899          		{
   4900          			ucOriginalNotifyState = pxTCB->ucNotifyState;
   4901          			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
   4902          
   4903          			/* 'Giving' is equivalent to incrementing a count in a counting
   4904          			semaphore. */
   4905          			( pxTCB->ulNotifiedValue )++;
   4906          
   4907          			traceTASK_NOTIFY_GIVE_FROM_ISR();
   4908          
   4909          			/* If the task is in the blocked state specifically to wait for a
   4910          			notification then unblock it now. */
   4911          			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   4912          			{
   4913          				/* The task should not have been on an event list. */
   4914          				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   4915          
   4916          				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   4917          				{
   4918          					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   4919          					prvAddTaskToReadyList( pxTCB );
   4920          				}
   4921          				else
   4922          				{
   4923          					/* The delayed and ready lists cannot be accessed, so hold
   4924          					this task pending until the scheduler is resumed. */
   4925          					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   4926          				}
   4927          
   4928          				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   4929          				{
   4930          					/* The notified task has a priority above the currently
   4931          					executing task so a yield is required. */
   4932          					if( pxHigherPriorityTaskWoken != NULL )
   4933          					{
   4934          						*pxHigherPriorityTaskWoken = pdTRUE;
   4935          					}
   4936          
   4937          					/* Mark that a yield is pending in case the user is not
   4938          					using the "xHigherPriorityTaskWoken" parameter in an ISR
   4939          					safe FreeRTOS function. */
   4940          					xYieldPending = pdTRUE;
   4941          				}
   4942          				else
   4943          				{
   4944          					mtCOVERAGE_TEST_MARKER();
   4945          				}
   4946          			}
   4947          		}
   4948          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   4949          	}
   4950          
   4951          #endif /* configUSE_TASK_NOTIFICATIONS */
   4952          
   4953          /*-----------------------------------------------------------*/
   4954          
   4955          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4956          
   4957          	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
   4958          	{
   4959          	TCB_t *pxTCB;
   4960          	BaseType_t xReturn;
   4961          
   4962          		/* If null is passed in here then it is the calling task that is having
   4963          		its notification state cleared. */
   4964          		pxTCB = prvGetTCBFromHandle( xTask );
   4965          
   4966          		taskENTER_CRITICAL();
   4967          		{
   4968          			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
   4969          			{
   4970          				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   4971          				xReturn = pdPASS;
   4972          			}
   4973          			else
   4974          			{
   4975          				xReturn = pdFAIL;
   4976          			}
   4977          		}
   4978          		taskEXIT_CRITICAL();
   4979          
   4980          		return xReturn;
   4981          	}
   4982          
   4983          #endif /* configUSE_TASK_NOTIFICATIONS */
   4984          /*-----------------------------------------------------------*/
   4985          
   4986          
   4987          static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
   4988          {
   4989          TickType_t xTimeToWake;
   4990          const TickType_t xConstTickCount = xTickCount;
   4991          
   4992          	#if( INCLUDE_xTaskAbortDelay == 1 )
   4993          	{
   4994          		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
   4995          		reset to pdFALSE so it can be detected as having been set to pdTRUE
   4996          		when the task leaves the Blocked state. */
   4997          		pxCurrentTCB->ucDelayAborted = pdFALSE;
   4998          	}
   4999          	#endif
   5000          
   5001          	/* Remove the task from the ready list before adding it to the blocked list
   5002          	as the same list item is used for both lists. */
   5003          	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   5004          	{
   5005          		/* The current task must be in a ready list, so there is no need to
   5006          		check, and the port reset macro can be called directly. */
   5007          		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
   5008          	}
   5009          	else
   5010          	{
   5011          		mtCOVERAGE_TEST_MARKER();
   5012          	}
   5013          
   5014          	#if ( INCLUDE_vTaskSuspend == 1 )
   5015          	{
   5016          		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   5017          		{
   5018          			/* Add the task to the suspended task list instead of a delayed task
   5019          			list to ensure it is not woken by a timing event.  It will block
   5020          			indefinitely. */
   5021          			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
   5022          		}
   5023          		else
   5024          		{
   5025          			/* Calculate the time at which the task should be woken if the event
   5026          			does not occur.  This may overflow but this doesn't matter, the
   5027          			kernel will manage it correctly. */
   5028          			xTimeToWake = xConstTickCount + xTicksToWait;
   5029          
   5030          			/* The list item will be inserted in wake time order. */
   5031          			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   5032          
   5033          			if( xTimeToWake < xConstTickCount )
   5034          			{
   5035          				/* Wake time has overflowed.  Place this item in the overflow
   5036          				list. */
   5037          				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   5038          			}
   5039          			else
   5040          			{
   5041          				/* The wake time has not overflowed, so the current block list
   5042          				is used. */
   5043          				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   5044          
   5045          				/* If the task entering the blocked state was placed at the
   5046          				head of the list of blocked tasks then xNextTaskUnblockTime
   5047          				needs to be updated too. */
   5048          				if( xTimeToWake < xNextTaskUnblockTime )
   5049          				{
   5050          					xNextTaskUnblockTime = xTimeToWake;
   5051          				}
   5052          				else
   5053          				{
   5054          					mtCOVERAGE_TEST_MARKER();
   5055          				}
   5056          			}
   5057          		}
   5058          	}
   5059          	#else /* INCLUDE_vTaskSuspend */
   5060          	{
   5061          		/* Calculate the time at which the task should be woken if the event
   5062          		does not occur.  This may overflow but this doesn't matter, the kernel
   5063          		will manage it correctly. */
   5064          		xTimeToWake = xConstTickCount + xTicksToWait;
   5065          
   5066          		/* The list item will be inserted in wake time order. */
   5067          		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   5068          
   5069          		if( xTimeToWake < xConstTickCount )
   5070          		{
   5071          			/* Wake time has overflowed.  Place this item in the overflow list. */
   5072          			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   5073          		}
   5074          		else
   5075          		{
   5076          			/* The wake time has not overflowed, so the current block list is used. */
   5077          			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   5078          
   5079          			/* If the task entering the blocked state was placed at the head of the
   5080          			list of blocked tasks then xNextTaskUnblockTime needs to be updated
   5081          			too. */
   5082          			if( xTimeToWake < xNextTaskUnblockTime )
   5083          			{
   5084          				xNextTaskUnblockTime = xTimeToWake;
   5085          			}
   5086          			else
   5087          			{
   5088          				mtCOVERAGE_TEST_MARKER();
   5089          			}
   5090          		}
   5091          
   5092          		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
   5093          		( void ) xCanBlockIndefinitely;
   5094          	}
   5095          	#endif /* INCLUDE_vTaskSuspend */
   5096          }
   5097          
   5098          /* Code below here allows additional code to be inserted into this source file,
   5099          especially where access to file scope functions and data is needed (for example
   5100          when performing module tests). */
   5101          
   5102          #ifdef FREERTOS_MODULE_TEST
   5103          	#include "tasks_test_access_functions.h"
   5104          #endif
   5105          
   5106          
   5107          #if( configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1 )
   5108          
   5109          	#include "freertos_tasks_c_additions.h"
   5110          
   5111          	#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
   5112          		static void freertos_tasks_c_additions_init( void )
   5113          		{
   5114          			FREERTOS_TASKS_C_ADDITIONS_INIT();
   5115          		}
   5116          	#endif
   5117          
   5118          #endif
   5119          
   5120          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   eTaskConfirmSleepModeStatus
       0   pcTaskGetName
      32   prvIdleTask
        32   -> uxListRemove
        32   -> vListInsertEnd
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vPortSuppressTicksAndSleep
      24   ulTaskNotifyTake
        24   -> uxListRemove
        24   -> vListInsert
        24   -> vListInsertEnd
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
       0   uxTaskGetNumberOfTasks
       0   uxTaskResetEventItemValue
      32   vTaskDelayUntil
        32   -> uxListRemove
        32   -> vListInsert
        32   -> vListInsertEnd
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
       0   vTaskEndScheduler
         0   -> vPortEndScheduler
       0   vTaskInternalSetTimeOutState
       0   vTaskMissedYield
      24   vTaskNotifyGiveFromISR
        24   -> uxListRemove
        24   -> vListInsertEnd
        24   -> vPortValidateInterruptPriority
      16   vTaskPlaceOnEventList
        16   -> uxListRemove
         0   -> vListInsert
        16   -> vListInsert
         0   -> vListInsertEnd
      24   vTaskPlaceOnEventListRestricted
        24   -> uxListRemove
         0   -> vListInsert
        24   -> vListInsert
         0   -> vListInsertEnd
        24   -> vListInsertEnd
      16   vTaskPlaceOnUnorderedEventList
        16   -> uxListRemove
         0   -> vListInsert
        16   -> vListInsert
         0   -> vListInsertEnd
        16   -> vListInsertEnd
      16   vTaskRemoveFromUnorderedEventList
        16   -> uxListRemove
        16   -> vListInsertEnd
      16   vTaskResume
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
         0   -> vPortExitCritical
       8   vTaskSetTimeOutState
         8   -> vPortEnterCritical
         0   -> vPortExitCritical
      16   vTaskStartScheduler
        16   -> __aeabi_memset4
        16   -> pvPortMalloc
        16   -> pxPortInitialiseStack
        16   -> vListInitialise
        16   -> vListInitialiseItem
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vPortFree
         0   -> xPortStartScheduler
        16   -> xTimerCreateTimerTask
       0   vTaskStepTick
      16   vTaskSuspend
        16   -> uxListRemove
        16   -> vApplicationStackOverflowHook
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
       0   vTaskSuspendAll
       8   vTaskSwitchContext
         8   -> vApplicationStackOverflowHook
      24   xTaskCheckForTimeOut
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
      40   xTaskCreate
        40   -> __aeabi_memset4
        40   -> pvPortMalloc
        40   -> pxPortInitialiseStack
        40   -> vListInitialise
        40   -> vListInitialiseItem
        40   -> vListInsertEnd
        40   -> vPortEnterCritical
        40   -> vPortExitCritical
        40   -> vPortFree
      24   xTaskGenericNotify
        24   -> uxListRemove
        24   -> vListInsertEnd
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
      32   xTaskGenericNotifyFromISR
        32   -> uxListRemove
        32   -> vListInsertEnd
        32   -> vPortValidateInterruptPriority
       0   xTaskGetSchedulerState
       0   xTaskGetTickCount
       8   xTaskGetTickCountFromISR
         8   -> vPortValidateInterruptPriority
      24   xTaskIncrementTick
        24   -> uxListRemove
        24   -> vListInsertEnd
       8   xTaskNotifyStateClear
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
      24   xTaskNotifyWait
        24   -> uxListRemove
        24   -> vListInsert
        24   -> vListInsertEnd
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
      16   xTaskRemoveFromEventList
        16   -> uxListRemove
        16   -> vListInsertEnd
      32   xTaskResumeAll
        32   -> uxListRemove
        32   -> vListInsertEnd
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
      24   xTaskResumeFromISR
        24   -> uxListRemove
        24   -> vListInsertEnd
        24   -> vPortValidateInterruptPriority


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable22
       4  ??DataTable24
       4  ??DataTable34
       4  ??DataTable34_1
       8  ?_0
      40  eTaskConfirmSleepModeStatus
      20  pcTaskGetName
     538  prvIdleTask
     168  ulTaskNotifyTake
      10  uxTaskGetNumberOfTasks
      22  uxTaskResetEventItemValue
     556  vTaskDelayUntil
      28  vTaskEndScheduler
      18  vTaskInternalSetTimeOutState
      12  vTaskMissedYield
     142  vTaskNotifyGiveFromISR
     102  vTaskPlaceOnEventList
     120  vTaskPlaceOnEventListRestricted
     118  vTaskPlaceOnUnorderedEventList
      88  vTaskRemoveFromUnorderedEventList
     120  vTaskResume
      36  vTaskSetTimeOutState
     404  vTaskStartScheduler
      32  vTaskStepTick
     302  vTaskSuspend
      16  vTaskSuspendAll
     142  vTaskSwitchContext
       4  xIdleTaskHandle
     212  xPendingReadyList
          pxReadyTasksLists
          pxCurrentTCB
          pxDelayedTaskList
          pxOverflowDelayedTaskList
          xSuspendedTaskList
          uxCurrentNumberOfTasks
          xTickCount
          uxTopReadyPriority
          xSchedulerRunning
          uxPendedTicks
          xYieldPending
          xNumOfOverflows
          uxTaskNumber
          xNextTaskUnblockTime
          uxSchedulerSuspended
          xDelayedTaskList1
          xDelayedTaskList2
      96  xTaskCheckForTimeOut
     546  xTaskCreate
     194  xTaskGenericNotify
     210  xTaskGenericNotifyFromISR
      28  xTaskGetSchedulerState
      10  xTaskGetTickCount
      20  xTaskGetTickCountFromISR
     208  xTaskIncrementTick
      40  xTaskNotifyStateClear
     198  xTaskNotifyWait
     130  xTaskRemoveFromEventList
     418  xTaskResumeAll
     128  xTaskResumeFromISR

 
   216 bytes in section .bss
     8 bytes in section .rodata
 5'276 bytes in section .text
 
 5'276 bytes of CODE  memory
     8 bytes of CONST memory
   216 bytes of DATA  memory

Errors: none
Warnings: none
